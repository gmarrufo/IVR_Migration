package com.ibm.ivr.eus.migration;

import java.io.*;
import java.util.*;

import javax.swing.JOptionPane;


/** Migrates the vru.ini and application ini files to framework XML files.
 * See README.txt for instructions on how to run
 * See migration.properties for configuration values
 * 
 * @author Greg
 */
public class Migration {
	
	// Set to true to dump out debug text files
	public static boolean debug = false;
	
	// Set to true if a console is available
	private static boolean console = false;

	// Default settings for the applications 
	private int invalid_select_max_default = 2;
	private int timeout_max_default = 2;
	//private String name = "SCA";
	private Menu globals = new Menu("GLOBAL_VARS");

	// Output folder
	private String output = "";
	private String currentIniName;

	// Menus to ignore from configuration file
	private Map<String, String> ignoreMenu = new HashMap<String, String>();
	private String ignoreMenus = "";
	private String LOGGER_PLUGIN_VARS = "";
	
	// List of possibilities for cur_appl - usually none, but could be set to XFER for example
	private List<String> curApplList = new ArrayList<String>();

	
	/** Entry point. Call main() to process ini files into framework XML files<br>
 	 * <h2>main()</h2> 
	 * Pass in migration.properties which lists ini files to process<br>
	 * @param args migration.properties If no properties file is supplied, usage is printed out 
	 */
	public static void main(String[] args) {
		
//		JOptionPane.showMessageDialog(null,"Current working directory:"+System.getProperty("user.dir")+":::"+new File(".").getAbsolutePath());
//		System.exit(0);


		String error = "";
		try {
			log(INFO,"***Note: Messages warning about extraneous input at EOF are generated by the parser and can be safely ignored");
			if(debug)
				Util.putFile("debug/expression.bad.txt","",false);
			new Migration().migrate();
		} catch(Exception e) {
			StringWriter sw = new StringWriter();
			e.printStackTrace(new PrintWriter(sw));
			error = "Error running migration: "+e.getClass().getName()+":"+e.getMessage()+"\r\n"+sw.toString();
			log(ERROR, error);
			
		}
		if(!console) {
			consolelog.insert(0, "Begin console log file. Set console=true when running Migration.main() within RAD development environment\r\n");
			Util.putFile("console.log.txt", consolelog.toString(), false);
			if(error.length() == 0)
				JOptionPane.showMessageDialog(null, "Migration complete. Results in console.log.txt");
			else
				JOptionPane.showMessageDialog(null, error);
		}

		//if(debug)
		//	MigrationDebug.dumpFunctions("expression.functions.txt");
	}

	/** Verifies that the files needed to perform the migration are found
	 */
	private void verifyValidEnvironment() {
		
		String props = Util.getFile("migration.properties");
		if(props == null || props.length() == 0) {
			props = Util.getFileOrResource("migration.properties");
			Util.putFile("migration.properties", props, false);
			JOptionPane.showMessageDialog(null, "Created migration.properties using built-in default copy. \r\nMake your changes to migration.properties and run the tool again.");
			System.exit(0);
		}

		/// Verify key configuration and template files are present
		String[] files = new String[]{"ini.zip"};
		for(int i=0;i<files.length;i++) {
			String filePath = Util.normalizePath(files[i]);
			if(!new File(filePath).exists())
				throw new RuntimeException("\nCould not find "+filePath+"\r\nSee README for instructions on setting up migration environment\r\n");
		}
		
		/// Verify migration.properties loads
		try { properties.load(new FileReader(Util.normalizePath("migration.properties"))); } catch(Exception e){
			e.printStackTrace();
			throw new RuntimeException("\nUnable to load migration.properties. Verify the file format is correct. "+e.getMessage());
		}

		boolean inDevelopmentMode = properties.getProperty("inDevelopmentMode","false").equals("true");
		String logLevelStr = properties.getProperty("logLevel","INFO");
		loglevel = logLevelStr.equalsIgnoreCase("DEBUG") ? DEBUG : logLevelStr.equalsIgnoreCase("TRACE") ? TRACE : INFO;
		debug = loglevel == DEBUG;
		
		/// Check to see if the compiler generator is part of the class path
		String base = "src/com/ibm/ivr/eus/migration/";
		String iniFileParser = "src/com/ibm/ivr/eus/migration/IniFileParser";
		String expressionXlateParser = "src/com/ibm/ivr/eus/migration/ExpressionXlateParser";
			
		String tool = properties.getProperty("cctool");
		try {
			
			/// Recreate the "Stub" files if they have been deleted. The stubs enable us to link to a fake compiler compiler 
			/// that can then be replaced with a real one at runtime
			if(inDevelopmentMode && !new File(iniFileParser+".java").exists() && !new File(expressionXlateParser+".java").exists()) {
				Util.putFile(expressionXlateParser+".java", Util.getFile(base+"/ParserStub.java").replace("ParserStub", "ExpressionXlateParser"), false);
				Util.putFile(iniFileParser+".java", Util.getFile(base+"/ParserStub.java").replace("ParserStub", "IniFileParser"), false);
				log(INFO, "Stub files ExpressionXlateParser.java and IniFileParser.java recreated");
				System.exit(0);
			}
			
			/// Verify the compiler generator tool loads
			Object cc = getInstance(tool);
			
			/// If the parser java files are small, that means that we are using stubs - replace the stubs with 
			/// files generated by the tool 
			if(inDevelopmentMode && new File(iniFileParser+".java").length() < 1024*10) {
				log(INFO, "(1 of 2) IniFileParser.java is a stub. Generating "+iniFileParser+".java Refresh and run the tool again to continue");
				runMethod(cc,"main", new Object[]{new String[]{"-o", "src/com/ibm/ivr/eus/migration", "src/IniFile.g"}});
			}
			if(inDevelopmentMode && new File(expressionXlateParser+".java").length() < 1024*10) {
				log(INFO, "(2 of 2) ExpressionXlateParser.java is a stub. Generating "+expressionXlateParser+".java Refresh and run the tool again to continue");
				runMethod(cc,"main", new Object[]{new String[]{"-o", "src/com/ibm/ivr/eus/migration", "src/ExpressionXlate.g"}});
			}
		} catch(Exception e) {
			
			String readme = Util.getFile("README.txt");
			if(readme == null || readme.length() == 0)
				readme = Util.getFile(getClass().getResourceAsStream("README.txt"));
			
			log(INFO,readme);
			System.out.flush();
			e.printStackTrace();
			throw new RuntimeException("\nUnable to run ANTLR. Download antlr-3.2.jar and add it to the current directory or your CLASSPATH. To use a different ANTLR version, change this jar file's manifest file. See README for additional information");
		}
	}


	/** Runs a method on an object. Used to call methods in the generated parser classes without being statically linked to a particular
	 * package
	 * @param o Call a method on this object 
	 * @param name Name of method
	 * @param args Args to methos - an array of object or null is no args
	 * @return Result of the method call
	 */
	private Object runMethod(Object o, String name, Object[] args) {
		if(args == null)
			args = new Object[]{};
		java.lang.reflect.Method[] methods = o.getClass().getMethods();
		/// For each method in the object, see if the method name and args match 
		 for(int i=0;i<methods.length;i++) {
			 try {
				 if(methods[i].getName().equalsIgnoreCase(name) && args.length == methods[i].getParameterTypes().length) {
					 boolean found = true;
					 Class[] types = methods[i].getParameterTypes();
					 for(int j=0;j<types.length;j++) {
						 if(!args[j].getClass().getName().replaceAll("java.lang.Integer", "int").equals(types[j].getName().replaceAll("java.lang.Integer", "int")))
							 found = false;
					 }
					 /// - If the method is found, call it
					 if(found)
						 return methods[i].invoke(o, args);
				 }
			 } catch(Exception e) {
				 log(ERROR,"ERROR Evaluating "+ name+"(): "+e.getMessage());
				 e.printStackTrace();
			 }
		 }
		 return null;
	}

	
	
	/** Starting point of the migration
	 * <h2>migrate()</h2> 
	 * If vru.ini is specified, The output dir is deleted and the template.zip file will be unpacked and standard properties files will be overlayed.<br>
	 * See migration.properties for the full list of supported properties
	 * inidir=path/to/inifiles<br>
	 * process=list,of,files. Standard filesystem wildcards can be used.  If vru.ini is listed, that gets processed first. If vru.ini not listed, only application ini files listed will be regenerated<br>
	 * ignore= list,of,files. Standard filesystem wildcards can be used.<br>
	 * output=dir to output<br>
	 * timeout_max_default=default number of nomatch or noinput - defaults to 2<br>
	 * noinput_timeout=5s
	 * interdigit_timeout=3s
	 * host_timeout=20s
	 * <b>STEPS</b>
	*/
	Properties properties = new Properties();

	private static StringBuffer consolelog = new StringBuffer();
	public void migrate() {
		verifyValidEnvironment();
		
		List<VRUFile> entries = stage1VRU2Template("ini", "Template.zip");
		//for(int i=0;i<entries.length();i++) {
		// appName = entries[i].name;
		
 		/// <ol>
		/// <li> Get the list of files in the inidir
		String[] files = new File(Util.normalizePath("ini")).list();
		int attempts = 0;
		int errors = 0;
		String failures = "";
		
		
		String include = properties.getProperty("include");
		String force = properties.getProperty("force");
		
		String[] im = (""+properties.getProperty("ignore-menu")).split("\\|");
		for(int i=0;!im[0].equals("null") && i<im.length && im[i].length() > 0;i++) {
			String name = im[i].split(":")[0];
			String menus = ","+im[i].split(":")[1] + ",";
			ignoreMenu.put(name, menus);
		}
		
		String[] ignore = (""+properties.getProperty("ignore")).split(",");

		
		/// <li> For each ini file found in the inidir
		for(int i=0;i<files.length;i++) {
	 		globalRepeatKey = "*";
	 		globalBackupKey = "#";

			
			/// - If the ini file name does not match a file name from the "process" section, skip that file
	 		if(!include.equals("*") && !(","+include.toLowerCase()+",").contains(","+files[i].toLowerCase().replace(".ini", "")+","))
				continue;

			log(INFO, "Checking "+files[i]+" against ignore list");

	 		// See if any of the ignore files matches
	 		boolean bIgnore = false;
			for(int j=0;j<ignore.length;j++) {
				if(files[i].toLowerCase().matches(ignore[j])) {
					log(INFO, "File "+files[i]+" matches "+ignore[j]+", skipping...");
					bIgnore = true;
				}
			}
			
			if(bIgnore)
				continue;
			
			
			/// - If the file name matches a name from the "ignore" section, skip that file
			if(!force.equals("true") && (!files[i].endsWith(".ini")|| files[i].endsWith("vru.ini")|| files[i].endsWith("ticket_methodology.ini") || files[i].endsWith("recor.ini") || files[i].endsWith("xfer.ini")|| files[i].endsWith("ipagent_route.ini")|| files[i].endsWith("gvi_route_cf.ini")|| files[i].endsWith("gvi_route.ini") || files[i].endsWith("agent_admin.ini")|| files[i].endsWith("_route.ini")|| files[i].endsWith("chrxfer.ini")|| files[i].endsWith("euxfer.ini"))) {
				failures+=files[i]+" (skipped, not an application)\r\n";
				continue;
			}

			String appName = files[i].split("\\.")[0]; 
			this.currentIniName = appName;
			/// - Create a "ininame.todo.txt" file which summarizes all the <TO DO> elements which are added to the output XML file  
			try { new File(Util.normalizePath(this.currentIniName+".todo.txt")).delete();} catch(Exception e){}; 
			
			ignoreMenus = ""+ignoreMenu.get(appName);
			attempts++;
			try {
				/// - Call  stage2GenerateSimpleREXX2FrameworkXML() to generate framework XML for this ini file
				stage2GenerateSimpleREXX2FrameworkXML(appName, "ini", entries);
			} catch(Exception e) {
				//if(e.getMessage().indexOf("NoGLOBAL_VARS") >= 0) {
				//	log(DEBUG, e.getMessage());
				//	attempts--;
				//} else 
				{
					failures += appName+".ini Reason:"+(e.getClass().getName()+":"+e.getMessage()).trim()+"\r\n";
					e.printStackTrace();
					errors++;
				}
			}
		}
		
		// generate RECORD_APP.properties
		generateRecordAppProperties();

		// Generate xfer.properties
		String[] xfer_files = (""+properties.getProperty("xfer_files")).split(",");
		for(int i=0;xfer_files[0].length() > 0 && !xfer_files[0].equals("null") && i<xfer_files.length;i++)
			generateXferProperties(xfer_files[i]);

		
		/// <li> Print out success rate
		/// </ol>
		int percent = attempts > 0 ? (attempts - errors) * 100 / attempts : 0;
		log(INFO, "Files:"+attempts+" Success:"+(attempts - errors)+" Percent:"+percent+ "\n****************************************\r\n"+(failures.length() > 0 ? "Errors encountered processing the following files:\r\n"+failures : ""));
		//}
	}
	

 	
	/** Unpacks the template.zip file
	 * @param pathToVRUini
 	 * @param path2Template
 	 * @return List of ini file entries e.g. sca.ini
	 * <h2>stage1VRU2Template</h2>
	 * This process unpacks the template.zip file and creates the framework properties files for the application
	 * - The template.zip file contains a template for the framework web application
	 * - The zip file is unpacked to a folder by the name "SCA". 
	 * - Individual applications inside the SCA will become "CallRoutingConfig/appname.xml"
	 * - This process creates the global properties files for the app
	 * <br>
	 * <b>STEPS</b>
	 */
	List<VRUFile> stage1VRU2Template(String pathToVRUini, String path2Template) {
		/// <ol>
		/// <li> CREATE a new framework “Template” Project and rename it to sca
		FrameworkTemplate ft = new FrameworkTemplate();
		
		// Unpack ini.zip to the ini folder
		ft.unpackIni("ini.zip");
		
		///  <li> OPEN vru.ini and get list of ini file entries e.g. sca.ini
		VRUFile vru = new VRUFile();
		log(TRACE,"Loading vru.ini");
		List<VRUFile> entries = vru.interpret(pathToVRUini+"/vru.ini");

		String property_path = Util.normalizePath(properties.getProperty("property_path"));
		if(property_path == null || property_path.length() == 0)
			return entries;

		// Set up the base path for the properties files
		ft.basePath = property_path;

		//ft.unpack(path2Template, name);


		///  <li> Create DNIS mapping files
		// - genUrlmappingProperties(entries);
		//ft.genUrlmappingProperties(entries);
		/// - genivrmappingProperties(entries);
		ft.genivrmappingProperties(entries);
		/// - genapplicationCallProperties(entries);
		ft.genapplicationCallProperties(entries);
		/// - genlog4jProperties(entries);
		ft.genlog4jProperties(entries);
		/// - genGlobalProperties(entries)
		ft.genGlobalProperties(entries);
		// - genReportMappingProperties(entries);
		//ft.genReportMappingProperties(entries);
		/// </ol>
		
		return entries;
	}

	/** Generates framework XML
	 * @param appName Name of the application e.g. ace.ini -> ace
	 * @param pathToIni File system path to the ini file e.g. ini/ace.ini
	 * @param entries The [SECTION] entries in the file
	 * 
	 * <h2>Generate Simple REXX to Framework XML</h2> 
	 * Generates framework XML for each application ini file passed to the tool.<br>
	 * In general, for each [SECTION] in the ini file, Generate a framework <SubMenu> <BR>
	 * For each variable reference, Generate a framework <Set> call <BR>
	 * For example:<br>
	 <pre>
	 [GLOBAL_VARS]
	 status_avoided			= 'N'
	 </pre>
	Is translated to framework XML like this<br>
	 <pre>
	 <SubMenu name='GLOBAL_VARS' handler="com.ibm.ivr.framework.sca.SCASupportHandler">
		<Set name='status_avoided' expr="'N'"/>
		...
	 </pre><br>
	 * <b>STEPS</b>
	*/
 	void stage2GenerateSimpleREXX2FrameworkXML(String appName, String pathToIni, List<VRUFile> entries) {
 		processed.clear();
		globals.clear(); //	remove("fileout"); globals.remove("lineout");
		LOGGER_PLUGIN_VARS = "";
		log_data = "";
		if(debug) Util.putFile("debug/expression.good.txt", "",false);
		if(debug) Util.putFile("debug/expression.bad.txt", "",false);


 		INIFile ini = new INIFile();
 		// call_flow_name			= 'ACE' file name
 		String menus = "";
 		/// <ol>
 		/// <li> Get the list of [SECTIONS] from the ini file
 		List<String []> sections = ini.getSections(pathToIni+"/"+appName+".ini");
 		if(sections == null || sections.size() == 0)
 			throw new RuntimeException("NoSections:No sections found in "+appName+".ini");
 		/// <li> For each [SECTION]
 		for(int i=0;i<sections.size();i++) {
 		/// - Translate each [SECTION] into a menu using translateSection()
 			menus += translateSection(sections.get(i), appName, ini);
 		}

 		
 		/// <li> Add sub menus to handle application NOMATCH and NOINPUT:
 		/// <pre>
 		/// default_invalid_select_action   = 'LINK_GENME;cur_ini = ACE'
 		///	default_timeout_action          = 'LINK_GENME;cur_ini = ACE'
 		/// </pre>
 		/// becomes <InputError> which wind up transferring to:
 		/// <pre>
 		/// <SubMenu name='NomatchMenu'>
 		///   <Audio>nomatch</Audio>
 		///   <MenuDefault targetType='submenu' targetName='(getInvalidSelectDest())' />
 		/// </SubMenu>
 		/// <SubMenu name='NoinputMenu'>
 		///   <Audio>noinput</Audio>
 		///   <MenuDefault targetType='submenu' targetName='(getTimeoutDest())' />
 		/// </SubMenu>
 		/// </pre>

 		String contents = "";
 		
// 		contents += generateFrameworkSection(audio, new String[]{"TTS","nomatch","WAV","(wav(nomatch))"}, false);
// 		contents += generateFrameworkSection(menuDefaultSubmenu, new String[] {"DEST", "(getInvalidSelectDest())", "HANDLER", ""}, false);
// 		menus += generateFrameworkSection(subMenu, new String[] {"MENU_NAME", "NomatchMenu", "MENU_CONTENTS", contents, "HANDLER",""}, false);

// 		contents = "";
// 		contents += generateFrameworkSection(audio, new String[]{"TTS","noinput","WAV","(wav(noinput))"}, false);
// 		contents += generateFrameworkSection(menuDefaultSubmenu, new String[] {"DEST", "(getTimeoutDest())", "HANDLER", ""}, false);
 		
 		String hup = generateFrameworkSection(nextMenuFragment, new String[]{"NEXTMENU", "HUP"}, false);

 		int dNMNI = Util.val(properties.getProperty("defaultNomatchNoinputCount", "1"));
 		for(int i=1;i<=dNMNI;i++) {
	 		contents += generateFrameworkSection(noinput, new String[]{"COUNT", "count='"+i+"'", "REPROMPT", ""+(i != dNMNI) ,"WAV",i == dNMNI ? "<!-- hangup as specified in GENME -->" : "9002.wav","NEXTMENU",i == dNMNI ? hup : ""}, false);
	 		contents += generateFrameworkSection(nomatch, new String[]{"COUNT", "count='"+i+"'", "REPROMPT",  ""+(i != dNMNI) ,"WAV",i == dNMNI ? "<!-- hangup as specified in GENME -->" : "9003.wav","NEXTMENU",i == dNMNI ? hup : ""}, false);
 		}

 		menus 	= "\t<!-- Default event handlers for nomatch and noinput. Overridden in the individual menus -->\r\n" +
 				"\t<EventHandlers>\r\n"
 				+ contents
 				//+ generateFrameworkSection(subMenu, new String[] {"MENU_NAME", "NoinputMenu", "MENU_CONTENTS", contents, "HANDLER",""}, false);
 				+ "\t</EventHandlers>\n" + menus;
		
 		/// <li> Read in Template.zip!WebContent\WEB-INF\CallRoutingConfig\TemplateApp.xml as the application template file
 		/// - Write the file to /WebContent/WEB-INF/CallRoutingConfig/$APP_NAME.xml:
 		/// - Replace all $APP_NAME with the application name. 
 		/// - Replace $MENUS with the menus we just generated
/// <pre>
/// <CallRouting name="$appName" releaseVersion="1.0" fileVersion="$Revision: 1.1 $"
/// 	audioDir="$appName" start="GLOBAL_VARS" startMode="DTMF"
/// 	main="GLOBAL_VARS"
/// 	callProperties="call.properties"
/// 	xmlns="http://ibm.com/ivr/framework/model"
/// 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
/// 	xsi:schemaLocation="http://ibm.com/ivr/framework/model IVRFramework.xsd">
///   ...
///   $MENUS
/// </pre>
 		/// </ol>
 		console = ("true".equalsIgnoreCase(""+properties.get("console")));
 		output = properties.getProperty("output"); 
		String path = output;
		String helpers = properties.getProperty("uses-helpers"); 
		String common = (","+helpers+",").contains(","+appName+",") ? "common-globals.xml,common-"+appName+".xml" : "common-globals.xml";
		
			//name+"/WebContent/WEB-INF/CallRoutingConfig";
		String buff = Util.getFileOrResource("TemplateApp.xml");
		log(INFO, "TemplateApp.xml loaded: "+buff.length() +" bytes");
		menus = menus.replace("LOGGER_PLUGIN_VARS", LOGGER_PLUGIN_VARS);
		String REPEAT_KEY = "";
		String BACKUP_KEY = "";
		
		if(globalRepeatKey.length() == 1 && !"ignore".equalsIgnoreCase(properties.getProperty("globalRepeatKey")))
			REPEAT_KEY = "	globalRepeatKey=\""+globalRepeatKey+"\" "; 
		if(globalBackupKey.length() == 1&& !"ignore".equalsIgnoreCase(properties.getProperty("globalBackupKey")))
			BACKUP_KEY = "	globalBackupKey=\""+globalBackupKey+"\""; 

		buff = buff.replaceAll("globalRepeatKey=\"\"",REPEAT_KEY);
		buff = buff.replaceAll("globalBackupKey=\"\"",BACKUP_KEY);
		buff = buff.replaceAll("\\$COMMON",common);
		buff = buff.replaceAll("\\$appName",appName);
		buff = buff.replaceAll("\\$MENUS",menus);
		buff = buff.replace("DOLLAR_SIGN", "$");
		buff = buff.replaceAll("menuLevel EQ","\\$menuLevel EQ");
		path += "/"+appName+".xml"; 
		log(INFO, ">>>>>>>>>>>>>>>>>>>>Writing "+path); 
		if(!Util.putFile(path, buff, false))
			log(ERROR, "File Write failed: "+path);
	}

 	/** Single point to generate cond="..." attribute
 	 * 
 	 * @param lhs left hand side
 	 * @param op operator
 	 * @param rhs right hand side
 	 * @return the cond attribute
 	 */
 	static String cond(String lhs, String op, String rhs) {
 		return(""+lhs+" EQ "+rhs.replaceAll("'", "")+"");
 	}
	
  	
 	private Set<String> processed = new HashSet<String>();
 	private String noMatchNoInput = "";

	private String globalRepeatKey;

	private String globalBackupKey;

	private String HUP_MENU_CHECK = "";

 	/** Translates [SECTION] variables into framework simple structures
 	 * @param lines Lines from the ini file
 	 * @param appName Name of the application e.g. ace[.ini]
 	 * @param ini ace.ini file
 	 * @return A string containing framework structures
 	 * 
 	 * <h3> Translate [Section]</h3>
	 * IF translation is incomplete THEN
	 * Add a < To Do linecontents > for each line that cannot be processed  
	 * <br>
	 * <b>STEPS</b> 	 
	 */
 	String translateSection(String[] lines, String appName, INIFile ini) {
 		//noMatchNoInput = "";
 		curApplList.clear();
 		String comment	 = "";
		boolean menuDefault = false;
		if(lines == null || lines.length == 0)
			return("");

  		String menuName = lines[0].trim();
//  		if(menuName.equals("XFER_VARS"))
// 			log(INFO,"HERE");
  		
  		if(processed.contains(menuName))
  			return("");
  		processed.add(menuName);
  		
  		boolean isVars = menuName.contains("_VARS");
  		
  		// Add in _CHECK lines
  		if(menuName.endsWith("_MENU")) {
			String[] lines2 = ini.getSection(null, menuName.replace("_MENU", "_CHECK"));
			if(lines2 != null && lines2.length > 0) {
				ArrayList l = new ArrayList();
				l.addAll(Arrays.asList(lines));
				l.addAll(1, Arrays.asList(lines2));
				l.remove(1);
				lines = (String [])l.toArray(new String[l.size()]);
			}
  		}
//  		if(!isVars)
//  			menuName = menuName.substring(0,menuName.lastIndexOf('_'));

 		String menus = "", contents = "";
  		Menu menu = new Menu(menuName);

  		
		// If the menu is global_vars, add logging variables
  		if(menuName.equals("GLOBAL_VARS")) {
  			contents += "LOGGER_PLUGIN_VARS";
			
			contents += generateSet(menu, "ini_file", currentIniName+".xml", "");

  		}

  		/// <b> 1. Convert the ini file lines (statements) into XML</b><br> 
  		/// For each line, if it is in the form of a statement, call translateStatement() on that line<br>
  		/// translateStatement() will build up the list of variables (a=b) and menu choices (main_1;...)<br>
  		/// The ANTLR compiler generator tool is used to run a 'statement grammar' against each line<br>
  		/// The result is an abstract syntax tree (AST) that is walked when generating framework XML structures<br>
  		/// Statement syntax is as follows:<br>
  		/// <pre>
  		/// statement:
  		///   label 
  		/// | (IDENT '=') => assignStatement -> ^(ASSIGN assignStatement) 
  		/// | (IF) => ifStatement -> ^(IF ifStatement)
  		/// | ((NUMBER | IDENT | IDENT2 | PHONE) (';' | '|')) => dtmfTableEntry -> ^(CHOICE dtmfTableEntry)
  		/// | ('say') => sayStatement -> ^(SAY sayStatement)
  		/// | (IDENT '=' 'esmrt_logger') => loggerExpression 
  		/// | ('CALL' 'LINEOUT') => 'CALL' 'LINEOUT' expression (',' expression)*  
  		/// | ('Call' 'SYSSLEEP') => 'Call' 'SYSSLEEP' number  
  		/// | expression;
  		/// </pre>
  		/// In the syntax above, the right arrow designator is used to 'remap' the ANTLR's output to<br>
  		/// make it easier to process by the antlr tool e.g. the remapping:
  		/// <pre>
  		/// '->' ^(ASSIGN assignStatement)
  		/// </pre>
  		/// Is used to remap the results to a tree with a root node of ASSIGN, which is easier to process in the tool
  		/// Here are examples of the syntax we support, and will have logic to remap to framework xml:
  		/// <pre>
  		/// #ASSIGN, IF, CHOICE, SAY
  		/// a='b'
  		/// IF a='b' THEN x="user_selection="user_selection" fn(a)="fn(a)" time="TIME('N')
  		/// main_1;XFER_12345
  		/// say x
  		/// </pre>
  		Object root = null;
 		for(int i=1;i<lines.length;i++) {
 			 try { 
  				if(lines[i].trim().length() == 0 || lines[i].trim().startsWith("/*") || lines[i].trim().startsWith("//")) 
  					continue;
  				//if(lines[i].startsWith("main_") && lines[i].contains("XFER"))
  				//	log(INFO,"Processing xfer line: "+lines[i]);
  					
  				root = IniFileParser.parse(lines[i]);
  				
				//String result = ret.toString();//ret.value;
				if(getType(root) == IniFileParser.STATEMENT) {
					contents += translateStatement(menuName, menu, root, lines[i],"", lines[i]);
				}
		  		/// If the line is not recognized as a valid statement, put the following into the generated XML<br> 
		  		/// <pre>
		  		/// <TO DO description='Unable to parse line' reason='Parser not including: $line'> 
		  		/// </pre>
				// log(INFO,t.toStringTree());
				//printTree(tree,0); 
 			} catch(Exception e){
 				

				// if((parser.failed() || parser.getNumberOfSyntaxErrors() > 0) && 
/*				if(lines[i].trim().length() > 0 && !lines[i].trim().startsWith("/*") && !lines[i].trim().startsWith("//") 
					&&  !lines[i].contains("CALL LINEOUT") && !lines[i].toLowerCase().trim().startsWith("say")
					&& !lines[i].toLowerCase().trim().startsWith("main") && !lines[i].toLowerCase().trim().endsWith("time('n')") && !lines[i].toLowerCase().contains("trexx(set_timeout")) {
						e.printStackTrace();
						throw new RuntimeException("Parser not including:"+lines[i]);
				}
*/ 				
 				if(lines[i].trim().length() > 0 && !lines[i].trim().startsWith("/*") && !lines[i].trim().startsWith("//")) {
 					log(ERROR, TO_DO("Unable to parse line", lines[i]));
	 				e.printStackTrace();
	 				//throw new RuntimeException(e);
	 				contents += TO_DO("Unable to parse line", lines[i]);
 				}
 			}
 		}
 		
 		
 		// cur_appl			= 'GENME' only GENME supported now
 		String cur_appl = menu.get("cur_appl") != null ? eval(menu.get("cur_appl").expr) : "GENME";
		menuDefault |= menu.get("cur_ini") != null;

  		// Add in _CHECK TO DO
  		if(menuName.endsWith("_CHECK")) {
  			contents += TO_DO("Encountered _CHECK menu: "+menuName+" Added _CKECK contents to "+menuName.replace("_CHECK","_MENU")+" Verify first few lines of this menu are valid", "");
  		}

 		/// <b> 4. call generateSubmenuSet() to add <Set> elements for a=b or IF c=d THEN a=b </b><br>
 		contents += generateSubmenuSet(menu);

 		contents += menu.play_seg;
		//if(menuName != null && menuName.equals("GLOBAL_VARS"))
		//	contents += generateSet(null, "menuLevel", "(initMenu('"+menuName+"'))", null);

  		/// <b> 3. call generateSubmenuChoices() to add <Choice> elements for menus e.g. main_1;XFER_12345</b><br>
 		contents += generateSubmenuChoices(menu, menuName);
 		
 		
  		/// <b> 2. Verify the processor is GENME, XFER, ALPHAENT, WEBSV, or VOICE_TRUST</b><br>
 		/// Only these two are supported for the simple/medium case. All other processors generate:<br>
  		/// <pre>
  		/// < TO DO description='Unsupported processor' reason='$processor'> 
  		/// </pre>
 		if(cur_appl != null && !cur_appl.equals("GENME") && !cur_appl.equals("XFER") && !cur_appl.equals("ALPHAENT") 
 				&& !cur_appl.equals("WEBSV")&& !cur_appl.startsWith("VOICE_TRUST")
 				&& !cur_appl.equals("EFHENT") && !cur_appl.equals("RECFN") 
 				) {
 			comment += TO_DO("Verify menu translation is correct", cur_appl);
 			comment += "\n<!-- Menu '"+menuName+"' uses special processor named '"+cur_appl+"' \n";
 			for(int j=0;j<lines.length;j++) {
 				comment += lines[j].trim()+"\n";
 			}
 			comment += "-->\n";
 		}
  		
 		// call_status			= 'OK' HUP ends processing
 		//contents += generateFrameworkSection(menuDefaultHup, null);
 		
		// 		String cur_prompt = eval(vars.get("cur_prompt"));
		// 		if(cur_prompt != null)
		// 			contents += generateFrameworkSection(audio, new String[]{"TTS",cur_prompt,"WAV",cur_prompt+".wav"});

 		/// <b> 5. Add any <Audio> for play_seg=#### found in ini file section</b><br>
  		/// <pre>
  		/// play_seg                        = '90010' 
  		/// </pre>
 		/// becomes 
  		/// <pre>
		/// <Audio>85001.wav</Audio>
  		/// </pre>
 				
 		contents += processVoiceSegmentDatabase(appName.toUpperCase(), menuName, menu);
 		if(HUP_MENU_CHECK .length() > 0) {
 			contents += HUP_MENU_CHECK;
 			HUP_MENU_CHECK = "";
 		}


 		/// Process menu _CHECK, _VARS, _MENU e.g. 		[GLOBAL_VARS]
 		if(menu.choices == null) {
 			String unsupportedMenus = ","+properties.getProperty("unsupportedMenus")+",";
 			String unsupportedProcessors = ","+properties.getProperty("unsupportedProcessors")+",";
 			String unsupportedMenu = unsupportedMenus.contains(","+menuName+",") ? menuName.split("_")[0] : null;
 			unsupportedMenu = unsupportedProcessors.contains(","+cur_appl.toUpperCase()+",") ? cur_appl : unsupportedMenu;
 			
 			if(unsupportedMenu != null) {
 				String cur_ini = menu.get("cur_ini").expr;
 				contents += generateUnsupportedSubmenu(unsupportedMenu, cur_ini, menu);
 			} else if(menu.curIniCount > 1) {
 				contents += generateFrameworkSection(menuDefaultSubmenu, new String[]{"DEST","DOLLAR_SIGNcur_ini", "HANDLER", ""}, false);
			} else {
	 			Line line = menu.get("cur_ini");
	 			if(line == null) {
	 				log(DEBUG, "TODO cur_ini is null");
	 			} else {
	 				String m = eval(line.expr);
	 				if(m.indexOf("next_ini") >= 0) {
	 					m = "DOLLAR_SIGNnext_ini";
	 					contents += generateSet(null, "next_ini", "(MENUNAME(next_ini))", null);
	 					//|| m.indexOf("cur_ini") >= 0)
	 				}
	 				else if(Menu.menus.get(m) == null)
	 					m = m + "_VARS";
//	 				if(m.indexOf('(') >= 0) {
//	 					m = m.replaceAll("\\(", "DOLLAR_SIGN").replaceAll("\\)","");
//	 				}
	 				for(int ic=0;ic<curApplList.size();ic++) {
	 					contents += generateFrameworkSection(menuDefaultSubmenu, new String[]{"DEST",curApplList.get(ic)+"_MENU", "HANDLER", "cond=\"(cur_appl EQ '"+curApplList.get(ic)+"')\""}, false);
	 				}
	 				curApplList.clear();
	 				contents += generateFrameworkSection(menuDefaultSubmenu, new String[]{"DEST",m, "HANDLER", ((line.cond == null || line.cond.length() == 0) ? "" : "cond=\""+line.cond+"\"")}, false);
	 			}
	 		}
 		}

 		
		if(isVars) {
			if(!menuDefault) {
				if((""+cur_appl).equalsIgnoreCase("XFER"))
					contents += generateFrameworkSection(menuDefaultSubmenu, new String[]{"DEST","XFER_VARS", "HANDLER", "dest='DOLLAR_SIGNxfer_var'"}, false);
				else
					contents += generateFrameworkSection(menuDefaultSubmenu, new String[]{"DEST",menuName.substring(0,menuName.lastIndexOf('_'))+"_MENU", "HANDLER", ""}, false);
			}
	 		// Create the new menu
		}
		
  		/// <b> 6. Generate nomatch/noinput</b>
 		noMatchNoInput += generateNomatchNoinput(menu);

		
		/// <b> 7. Add the completed submenu to the application </b>
		/// - For GLOBAL_VARS, set handler='com.ibm.ivr.framework.sca.handlers.SCASupportHandler'
		/// - For ALPHAENT_VARS,handler='com.ibm.ivr.framework.sca.handlers.ALPHAENT' 
		String handler = menuName.equals("GLOBAL_VARS") ? ""//"handler='com.ibm.ivr.framework.sca.handlers.SCASupportHandler'" 
				//: menuName.equals("ALPHAENT_VARS") ? "handler='com.ibm.ivr.framework.sca.handlers.ALPHAENT'"
				//: menuName.equals("EFHENT_VARS") ? "handler='com.ibm.ivr.framework.sca.handlers.EFHENT'"
				//: menuName.equals("XFER_VARS") ? "handler='com.ibm.ivr.framework.sca.handlers.XFER'"
				: "";
		String type = menuName.endsWith("_VARS") ? menu.play_seg.length() > 0 ? " type='PromptPlay' " : " type='BusinessLogic' " : "";
		String nmni = menuName.endsWith("_MENU") ? noMatchNoInput : "";
		if(nmni.length() > 0)
			noMatchNoInput = "";
		
		menus = generateFrameworkSection(subMenu, new String[] {"MENU_NAME", menuName, "MENU_CONTENTS", contents + nmni, "HANDLER", handler, "TYPE", type}, false);
		if(isVars) {
			menus = menus + translateSection(ini.getSection(null, menuName+"_MENU"), appName, ini);
			menus = menus + translateSection(ini.getSection(null, menuName.replace("_VARS", "_CHECK")), appName, ini);
		}

		// If the menu is log_vars, add application and possibly esmart logging to global vars
  		if(menuName.equals("LOG_VARS")) {
  			//String ald = properties.getProperty("applicationLogData");
  			//if(ald != null)
  			//	LOGGER_PLUGIN_VARS += generateSet(null, "ApplicationLogData", ald, null);
  			for(int jj=0;jj<menu.lines.size();jj++) {
  				Line line = menu.lines.get(jj);
  				if("log_data".equals(line.var)) {
  					log_data += convertExpression(line.expr);
  				}
  			}
  			LOGGER_PLUGIN_VARS += generateSet(null, "applicationLogData", log_data.replaceAll("log_data", ""), null);
  			
  			
  		}

		
		return comment + menus;
	}
 	
 	

 	/** Generates the XML to call a web service using the WEBSV handler
 	 * 
 	 * @param cur_ini The name of the next menu to go to
 	 * @return The new XML file contents with <set> lineout and <menuDefault> WEBSV added
 	 * 
 	 * Calling a web service involves 3 steps:
 	 * <ol>
 	 * <li> Set lineout session variable to the contents of the message you want to send
 	 * <li> Set fileout session variable to the unique identifier for this message. This identifier used to map to a file in the filesystem, but now it can be used to tag and identify the message 
 	 * <li> Call a <menuDefault> with a handler of com.ibm.ivr.framework.sca.handlers.WEBSV
 	 * </ol>
 	 * 
 	 * Instead of setting lineout and fileout, you can call a handler that takes other parameters, but ultimately the WEBSV handler will utilize lineout and fileout
 	 * 
 	 * The example below puts together a SOAP packet and calls WEBSV to process it
<pre>
[POST_ACCESS_CODE_VARS]
cur_ini = 'SUBMIT_SOAP_REQUEST'

access_code = last_dtmf_data

ResoXMLfile = '.\RESOLight\'start_date||start_time'_'voice_line'_RESOLIGHT.xml'
responseXMLfile = '.\RESOLight\'start_date||start_time'_'voice_line'_RESOLIGHT_result.xml'

SAY ResoXMLfile

CALL LINEOUT ResoXMLfile, '<soapenv:Envelope'
CALL LINEOUT ResoXMLfile, 'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"'
CALL LINEOUT ResoXMLfile, 'xmlns:xsd="http://www.w3.org/2001/XMLSchema"'
CALL LINEOUT ResoXMLfile, 'xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">'
CALL LINEOUT ResoXMLfile, '<soapenv:Body>'
CALL LINEOUT ResoXMLfile, '<vbws:openNewRequest'
CALL LINEOUT ResoXMLfile, 'xmlns:vbws="http://spaceview.raleigh.ibm.com"'
CALL LINEOUT ResoXMLfile, 'soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">'
CALL LINEOUT ResoXMLfile, '<employeeSerialNumber xsi:type="xsd:string">'serial_num'</employeeSerialNumber>'
CALL LINEOUT ResoXMLfile, '<locationAccessCode xsi:type="xsd:string">'access_code'</locationAccessCode>'
CALL LINEOUT ResoXMLfile, '</vbws:openNewRequest>'
CALL LINEOUT ResoXMLfile, '</soapenv:Body>'
CALL LINEOUT ResoXMLfile, '</soapenv:Envelope>'
CALL LINEOUT ResoXMLfile, ''
rc=STREAM(ResoXMLfile, 'C', 'CLOSE')

SoapXMLfile = ResoXMLfile


[SUBMIT_SOAP_REQUEST_VARS]
cur_appl 	= 'WEBSV'
cur_function	= 'rc=simpleXMLresponse()'
cur_ini		= 'EXIT_SOAP_REQUEST'
</pre>
 	 gets translated to <br>	
<pre>
 	<SubMenu name='POST_ACCESS_CODE_VARS' >
		<Log>(ResoXMLfile)</Log>
		<Set name='access_code' expr="last_dtmf_data"/>
		<Set name='ResoXMLfile' expr="'.\RESOLight\'start_date||start_time'_'voice_line'_RESOLIGHT.xml'"/>
		<Set name='SoapXMLfile' expr="ResoXMLfile"/>
		<Set name='responseXMLfile' expr="'.\RESOLight\'start_date||start_time'_'voice_line'_RESOLIGHT_result.xml'"/>
		<Set name='rc' expr="STREAM"/>
		<MenuDefault targetType='submenu' targetName='SUBMIT_SOAP_REQUEST_VARS' />
	</SubMenu>
	<SubMenu name='SUBMIT_SOAP_REQUEST_VARS' >
		<Set name='cur_function' expr="'rc=simpleXMLresponse()'"/>
		<Set name='lineout' expr="(lineout + '<soapenv:Envelope')"/>
		<Set name='lineout' expr="(lineout + 'xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;')"/>
		<Set name='lineout' expr="(lineout + 'xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;')"/>
		<Set name='lineout' expr="(lineout + 'xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;>')"/>
		<Set name='lineout' expr="(lineout + '<soapenv:Body>')"/>
		<Set name='lineout' expr="(lineout + '<vbws:openNewRequest')"/>
		<Set name='lineout' expr="(lineout + 'xmlns:vbws=&quot;http://spaceview.raleigh.ibm.com&quot;')"/>
		<Set name='lineout' expr="(lineout + 'soapenv:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;>')"/>
		<Set name='lineout' expr="(lineout + '<employeeSerialNumber xsi:type=&quot;xsd:string&quot;>'serial_num'</employeeSerialNumber>')"/>
		<Set name='lineout' expr="(lineout + '<locationAccessCode xsi:type=&quot;xsd:string&quot;>'access_code'</locationAccessCode>')"/>
		<Set name='lineout' expr="(lineout + '</vbws:openNewRequest>')"/>
		<Set name='lineout' expr="(lineout + '</soapenv:Body>')"/>
		<Set name='lineout' expr="(lineout + '</soapenv:Envelope>')"/>
		<Set name='lineout' expr="(lineout + '')"/>
		<Set name='fileout' expr="ResoXMLfile"/>
		<MenuDefault targetType='submenu' targetName='EXIT_SOAP_REQUEST_VARS' handler='com.ibm.ivr.framework.sca.handlers.WEBSV'/>
		<MenuDefault targetType='submenu' targetName='EXIT_SOAP_REQUEST_VARS' />
	</SubMenu>
</pre>
 	 */
	String generateWEBSV(String contents, String cur_ini) {
		Object fileout = globals.get("fileout");
		if(fileout != null) {
			String lineout = ""+globals.get("lineout");
			String[] lineList = lineout.split("\n");
			for(int i=0;i<lineList.length;i++) {
				contents += generateSet(globals, "lineout", "(lineout + "+lineList[i].trim().replaceAll("\"", "&quot;")+")", null); 
			}
			contents += generateSet(globals, "fileout", fileout.toString(), null); 
//			globals.remove("fileout");
//			globals.remove("lineout");
		}
		contents += generateFrameworkSection(menuDefaultSubmenu, new String[]{"DEST",cur_ini+"_VARS", "HANDLER", "handler='com.ibm.ivr.framework.sca.handlers.WEBSV'"}, false);
		log(DEBUG,contents);
		return contents;
	}

	/** Generate a submenu call to a menu that is written by hand
	 * 
	 * @param menuName Name of menu
	 * @param nextMenu Name of menu to return to
	 * @param menu Menu contents
	 * @return The submenu XML
	 */
	String generateUnsupportedSubmenu(String menuName, String nextMenu, Menu menu) {
		String contents = "";
		Object fileout = globals.get("fileout");
		if(fileout != null) {
			contents += "<!-- The lines below contain data to be used by the special submenu we are calling\r\n";
			String lineout = ""+globals.get("lineout");
			String[] lineList = lineout.split("\n");
			for(int i=0;i<lineList.length;i++) {
				contents += generateSet(globals, "lineout", "(lineout + "+lineList[i].trim().replaceAll("\"", "&quot;")+")", null); 
			}
			contents += generateSet(globals, "fileout", fileout.toString(), null); 
			globals.lines.remove("fileout");
			globals.lines.remove("lineout");
			contents+="-->\r\n";
		}
		contents += TO_DO("Write sub menu by hand and put it into common-globals.xml", menuName+"_MENU");
		contents += generateFrameworkSection(menuDefaultSubmenu, new String[]{"DEST",menuName+"_MENU", "HANDLER", "dest='returnMenu:"+nextMenu+"_VARS'"}, false);
//		log("INFO",contents);
		return contents;
	}

/**
 * 
 * @param contents
 * @param cur_ini
 * @return
 * 
 * 	 * <h2> generateAlphaEnt </h2>
	 * Generates a <SubMenu> with an alpha numeric grammar based on the ALPHAENT handler (peer of GENME handler)<br>
	 * when cur_ini = 'ALPHAENT_VARS', we will add handler="com.ibm.ivr.framework.sca.handlers.ALPHAENT"
	 * inside the ALPHAENT_VARS <SubMenu><br>
	 * 
	 For example:<br>
	  <pre>
	  [ALPHAENT_VARS]
	  country_priority                = '897;US5;US6;649;CA2;CA3;CA4;CA6;CA7;CA8'
	  cur_appl                        = 'GENME'
	  cur_ini                         = 'OPTION0_STATUS'
	  serial_max                      = '8'
	  // an actual database containing employee serials - where to transfer phone, if you are authorized, etc. this way it can run standalone
	  sca_ent_db                      = 'IBMALPHA.VDB'
	  </pre>
	 Gets translated to:
	  <pre>
	<SubMenu name='ALPHAENT_VARS' handler='com.ibm.ivr.framework.sca.handlers.ALPHAENT'>
		<Set name='country_priority' expr="'897;US5;US6;649;CA2;CA3;CA4;CA6;CA7;CA8'"/>
		<Set name='serial_max' expr="'8'"/>
		<Set name='sca_ent_db' expr="'IBMALPHA.VDB'"/>
		<MenuDefault targetType='submenu' targetName='OPTION0_STATUS_VARS' />
	</SubMenu>
	 * </pre>

 */
  	/* String generateALPHAENT(String contents, String cur_ini) {
 
 		***NOTE*** ALPHAENT is now handled using generateUnsupportedSubmenu()
		return "";
	}*/
  	/**
  	 * 
  	 * @param contents
  	 * @param cur_ini
  	 * @return
  	 * 
  	 * Similar to ALPHAENT.	Generates XML for EFHENT european serial number entry handler 
	 * Generates a <SubMenu> with an alpha numeric grammar based on the ALPHAENT handler (peer of GENME handler)<br>
	 * when cur_ini = 'EFHENT_VARS', we will add handler="com.ibm.ivr.framework.sca.handlers.EFHENT"
	 * inside the EFHENT_VARS <SubMenu><br>
	 For example:<br>
	  <pre>
[EFHENT_VARS]
country_priority                = '866;754;838;724;706;758'
cur_appl                        = 'GENME'
cur_ini                         = 'IBMHELP'
serial_max                      = '9'
// an actual database containing employee serials - where to transfer phone, if you are authorized, etc. this way it can run standalone
sca_ent_db                      = 'EUEFH.VDB'
	  </pre>
	  Gets translated into:
	<pre>
	<SubMenu name='EFHENT_VARS' handler='com.ibm.ivr.framework.sca.handlers.EFHENT'>
		<Set name='country_priority' expr="'897;US5;US6;649;CA2;CA3;CA4;CA6;CA7;CA8'"/>
		<Set name='serial_max' expr="'8'"/>
		<Set name='sca_ent_db' expr="'IBMALPHA.VDB'"/>
		<MenuDefault targetType='submenu' targetName='OPTION0_STATUS_VARS' />
	</SubMenu>
	</pre>

  	 */
  	
  	/*String generateEFHENT(String contents, String cur_ini) {
 		***NOTE*** EFHENT is now handled using generateUnsupportedSubmenu()
  		 
		return "";
	}*/


	/** 
	 * 
	 * @param contents
	 * @param cur_ini
	 * @return
	 * 
	 * <h2>generateVOICE_TRUST</h2>
	 * Generates the reference to the VOICE_TRUST handler and passes in parameters used by this handler
	 * For example, this ini section:
	 <pre>
[VT_QUERY_PRE_CALL_VARS]
SAY "VT_QUERY_PRE_CALL"
VT_OPERATION			= 'Update'
vru_number 			= VRU_ANI||RIGHT(Telephone_number,4)
cur_appl			= 'VOICE_TRUST'
cur_ini				= 'VT_QUERY_POST_CALL'
cur_function			= 'rc=VT_Query()'
SAY "FINISHED VT_QUERY_PRECALL INTERPRETS"
</pre>

Gets translated to:

<pre>
  	<SubMenu name='VT_QUERY_PRE_CALL_VARS' >
		<Log>("VT_QUERY_PRE_CALL")</Log>
		<Log>("FINISHED VT_QUERY_PRECALL INTERPRETS")</Log>
		<Set name='VT_OPERATION' expr="'Update'"/>
		<Set name='cur_function' expr="'rc=VT_Query()'"/>
		<Set name='vru_number' expr="VRU_ANI"/>
		<MenuDefault targetType='submenu' targetName='VT_QUERY_POST_CALL_VARS' handler='com.ibm.ivr.framework.sca.handlers.VOICE_TRUST'/>
	</SubMenu>
</pre>

	 */
/*	String generateVOICE_TRUST(String contents, String cur_ini) {
		contents += generateFrameworkSection(menuDefaultSubmenu, new String[]{"DEST",cur_ini+"_VARS", "HANDLER", "handler='com.ibm.ivr.framework.sca.handlers.VOICE_TRUST'"}, false);
 		***NOTE*** VOICE_TRUST is now handled using generateUnsupportedSubmenu()
		log("INFO",contents);
		return contents;
	}*/

 	/** Generate the <Choice> elements for this menu
 	 * 
 	 * @param vars The variables for this menu
 	 * @param menuName The menu name
 	 * @return a list of menu <Choices>
	 * <h2> generateSubmenuChoices </h2>
	 * Choices: Choices are handled by recursively calling the current menu until the user gets to the last available choice or to a LINK.<br>
	 * for example <br>
<pre>
 [ACE_MENU]
 main_1_1;XFER_1062531
 main_1_2;XFER_918773014686
 main_1_3;XFER_1015156
 main_2_1;XFER_918008690996
 main_2_2_1;XFER_918009877260
 main_2_2_2;XFER_918008263237
 main_2_3;XFER_918003577472
 main_3_1;XFER_918778043934
 main_3_2;XFER_1015157
 main_4_1;XFER_918005084150
 main_4_2;XFER_918669436487
 main_4_3;XFER_918003440494
 main_4_4;XFER_918773014686
 main_4_5;XFER_1015161
 main_5;XFER_1015161
 main_7;XFER_1015496
 main_9;XFER_1015153
 main_*;LINK_GENME;cur_prompt='main';cur_ini='MAINSTAR'
 </pre>
 The lines in the format name_dtmf_dtmf_... ; LINK are recognized by the parser as choices. The list above translates to<br>
 <pre>
 		<Audio>wav('ACE_MENU/main'))</Audio>
		<Audio cond="menuLevel=='1'">wav('ACE_MENU/main_1')</Audio>
		<Audio cond="menuLevel=='2_2'">wav('ACE_MENU/main_2_2')</Audio>
		<Choice dtmf='1' expr="menuLevel='1'"  targetType='submenu' targetName='ACE_MENU'/>
			<!-- The following are sub selections of the 1 dtmf press -->
			<Choice cond="menuLevel=='1'"  dtmf='1' targetType='phone' targetName='main-1' dest='1062531'/>
		<Choice dtmf='9' targetType='phone' targetName='main-9' dest='1015153'/>

 </pre>
	 * <br>
	 * <b>STEPS</b>
 	 */
  	String generateSubmenuChoices(Menu menu, String menuName) {
  		if(menu.choices == null)
  			return("");
  		
  		///1.  Translate the choices to a string. for example: <br>
		/// <pre>
  		/// main_1_1;XFER_1062531
  		/// main_1_2;XFER_918773014686
  		/// </pre>
  		/// becomes 
		/// <pre>
		/// <Choice cond="menuLevel=='1'"  dtmf='1' targetType='phone' targetName='main-1' dest='1062531'/>
		/// <Choice cond="menuLevel=='1'"  dtmf='2' targetType='phone' targetName='main-2' dest='918773014686'/>
  		/// </pre>
  		
  		String prompts = menu.choices.toPrompt("", true);
  		String choices = menu.choices.toString();

  		
 		///2.  Add a InputError to handle NOMATCH and NOINPUT (invalid select and timeout) 
		/// <pre>
  		/// invalid_select_max              = '3'
  		/// timeout_max                     = '3'
  		/// </pre>
  		/// becomes 
		/// <pre>
		/// <InputError cond="noinput==timeout_max"   targetType='submenu' targetName='NoinputMenu'>
		/// </InputError>
		/// <InputError cond="nomatch==invalid_select_max"   targetType='submenu' targetName='NomatchMenu'>
		/// </InputError>
		/// <InputError  targetType='submenu' targetName='ACE_CICA_MENU'>
		///   (wav(getLastError()))
		/// </InputError>
 		/// </pre>
  		
  		
/* 		contents += generateFrameworkSection(nomatch, new String[]{"COUNT", "count='1'", "REPROMPT", "true","WAV","9002.wav","NEXTMENU",""}, false);
 		contents += generateFrameworkSection(nomatch, new String[]{"COUNT", "count='2'", "REPROMPT", "true","WAV","9002.wav","NEXTMENU",""}, false);
 		contents += generateFrameworkSection(nomatch, new String[]{"COUNT", "count='3'", "REPROMPT", "true","WAV","<!-- hangup as specified in GENME -->","NEXTMENU",hup}, false);

 		contents += generateFrameworkSection(noinput, new String[]{"COUNT", "count='1'", "REPROMPT", "true","WAV","9003.wav","NEXTMENU",""}, false);
 		contents += generateFrameworkSection(noinput, new String[]{"COUNT", "count='2'", "REPROMPT", "true","WAV","9003.wav","NEXTMENU",""}, false);
 		contents += generateFrameworkSection(noinput, new String[]{"COUNT", "count='3'", "REPROMPT", "true","WAV","<!-- hangup as specified in GENME -->","NEXTMENU",hup}, false);
*/
  		//generateFrameworkSection(inputError, new String[]{"NEXTMENU",nextMenuFragment.replaceAll("NEXTMENU", "NoinputMenu"),"WAV","" ,"COND", "noinput==timeout_max", "TTS", "","COUNT",""}, false);
  		//inputerrors += generateFrameworkSection(inputError, new String[]{"NEXTMENU",nextMenuFragment.replaceAll("NEXTMENU", "NomatchMenu"),"WAV","" ,"COND", "nomatch==invalid_select_max", "TTS", "","COUNT",""}, false);

  		//inputerrors += generateFrameworkSection(inputError, new String[]{"NEXTMENU",nextMenuFragment.replaceAll("NEXTMENU", ""+menuName),"TTS"," tts=\"eval(tts(lastError()))\" ","WAV","\t\t\t(wav(getLastError()))\r\n", "COND","", "COUNT", ""}, false);
  		return prompts + choices;
	}

	/** 
	 */
	public static String normalizeMenuName(String name, String type) {
		if(name.endsWith("_VARS") || name.endsWith("_MENU"))
			return name;
		return name.startsWith("GVI") ? name+"_MENU" : name + "_"+type;
		//return name + "_"+type;
	}
	
	
	/** Generate the nomatch and noinput choices for this menu
  	 * 
  	 * @param menu The menu object to work with
  	 * @return The nomatch and noinput XML
  	 */
	String generateNomatchNoinput(Menu menu) {
		String defaultNomatchNoinputCount = properties.getProperty("defaultNomatchNoinputCount","1");
		String inputerrors = "";
		String defaultNoMatch = "";
		String defaultNoInput = "";
		boolean defaultNMAdded = false;
		boolean defaultNIAdded = false;
		
		Line max = menu.get("invalid_select_max","");
		if(max != null && menu.get("default_invalid_select_action") == null) {
			menu.put("default_invalid_select_action", "'HUP'", null);
		}
		max = menu.get("timeout_max","");
		if(max != null && menu.get("default_timeout_action") == null) {
			menu.put("default_timeout_action", "'HUP'", null);
		}

  		//int noMatchMax = menu.get("invalid_select_max") == null ? 3 : Util.val(menu.get("invalid_select_max").expr.replaceAll("'",""));
  		//int noInputMax = menu.get("timeout_max") == null ? 3 : Util.val(menu.get("timeout_max").expr.replaceAll("'",""));
  		
// $$$ If noinput (nomatch) is generated but nomatch (noinput) default_invalid_select_action_XXX  is not specified
// Then we depend on the default <NoMatch> or <NoInput> handler. If the default does not work, we need to 
// go through these lines and add in the missing line dynamically at runtime - e.g. add in default_invalid_select_action_XXX
//  		for(int i=0;i<menu.lines.size();i++)
//				if(default_invalid_select_action_XXX is found) but default_timeout_action_XXX missing
//					menu.lines.add(default_timeout_action_XXX)			

		
		/// For each line in the menu
  		for(int ii=0;ii<menu.lines.size();ii++) {
  			String key = menu.lines.get(ii).var;
  			
  			/// If the line does not start with 'default_invalid_select' or 'default_timeout', continue
  			if(!(key.startsWith("default_invalid_select") || key.startsWith("default_timeout")) || key.startsWith("cond:")) 
  				continue;
  			String value = (""+menu.get(key).expr).replaceAll("'","");
// 			String origLink = value;
			String link = getLink(value);
			String vars = getLinkVars(value);
			String dest = vars.length() > 0 ? " dest=\""+ vars +"\" " : "";
			

			//String[] lookFor = "default_timeout_action,default_invalid_select_action,default_invalid_select_action_main_,default_invalid_select_action_main_".split(",");
			//for(int j=0;j<lookFor.length;j++)
  			String part1 = "default_invalid_select_action";

  			/// Generate nomatch/noinput corresponding to 'default_invalid_select...' or 'default_timeout...' lines
  			if(key.indexOf(part1) >= 0) {
  				String menuLevel = "M";
  				if(key.indexOf(part1+"_main_") >= 0) {
  					part1 = part1+"_main_";
  					menuLevel = key.substring(part1.length());
  				} else if(key.indexOf(part1+"_") >= 0) {
  					part1 = part1+"_";
  					menuLevel = key.substring(part1.length());
  				}

  				Line line = menu.get("invalid_select_max","");
  				String count = line == null ? defaultNomatchNoinputCount : line.expr.startsWith("(") ? ""+line.expr.charAt(1) : line.expr;	
				String cond = cond("menuLevel","==", "'"+menuLevel+"'");
				link = generateFrameworkSection(nextMenuFragment, new String[]{"NEXTMENU", normalizeMenuName(link,"MENU")}, false);

				String tempCond = menuLevel.equals("M") ? "" : cond;
				String tempNM = generateFrameworkSection(nomatch, new String[]{"COUNT", "count='"+count+"'" + dest, "COND", tempCond, "REPROMPT", "false","WAV","","NEXTMENU",link}, false);
				if(menuLevel.equals("M"))
					defaultNoMatch += tempNM;
				else 
					inputerrors += tempNM;

  				for(int k=1; !defaultNMAdded && k<Util.val(count);k++) {
 					defaultNoMatch += generateFrameworkSection(nomatch, new String[]{"COUNT", "count='"+k+"'", "COND", "", "REPROMPT", "true","WAV","9003.wav","NEXTMENU",""}, false);
  				}
  				defaultNMAdded = true;
				
					//for(int j=0;j<noMatchMax;j++) {
						//inputerrors += 
  					//inputerrors += "X X X"+parseChoice(("main_NoMatch;"+origLink).split(";"),"","");
		
  			}

  			part1 = "default_timeout_action";
  			if(key.indexOf(part1) >= 0) {
  				String menuLevel = "M";
  				if(key.indexOf(part1+"_main_") >= 0) {
  					part1 = part1+"_main_";
  					menuLevel = key.substring(part1.length());
  				} else if(key.indexOf(part1+"_") >= 0) {
  					part1 = part1+"_";
  					menuLevel = key.substring(part1.length());
  				}
  				String cond = cond("menuLevel","==", "'"+menuLevel+"'");
  				//if(dest.indexOf("curs_ini") >= 0 || cond.indexOf("main") >= 0)
  				//	log(INFO,"here: "+value);
  					
  				Line line = menu.get("timeout_max","");
  				String count = line == null ? defaultNomatchNoinputCount : line.expr.startsWith("(") ? ""+line.expr.charAt(1) : line.expr;
  				//if(Util.val(count) == 0)
  				//	System.err.println("here");
  				link = generateFrameworkSection(nextMenuFragment, new String[]{"NEXTMENU", normalizeMenuName(link,"MENU")}, false);

 				String tempCond = menuLevel.equals("M") ? "" : cond;
				String tempNI = generateFrameworkSection(noinput, new String[]{"COUNT", "count='"+count+"'" + dest, "COND", tempCond, "REPROMPT", "false","WAV","","NEXTMENU",link}, false);
				if(menuLevel.equals("M"))
					defaultNoInput += tempNI;
				else 
					inputerrors += tempNI;
				
 				for(int k=1;!defaultNIAdded &&  k<Util.val(count);k++) {
 					defaultNoInput += generateFrameworkSection(noinput, new String[]{"COUNT", "count='"+k+"'", "COND", "", "REPROMPT", "true","WAV","9002.wav","NEXTMENU",""}, false);
  				}

 				defaultNIAdded = true;
						//for(int j=0;j<noMatchMax;j++) {
							//inputerrors += parseChoice(menu.get(key).expr.split(";"),"","");
			
						//}

  			
  			}
  		
  		}
			String hup = generateFrameworkSection(nextMenuFragment, new String[]{"NEXTMENU", "HUP"}, false);

  		
/*  		if(!defaultNMAdded) {
  			String count = "3";
			for(int k=1;  k<Util.val(count);k++) {
				defaultNoMatch += generateFrameworkSection(nomatch, new String[]{"COUNT", "count='"+k+"'", "COND", "", "REPROMPT", "true","WAV","9003.wav","NEXTMENU",""}, false);
			}
  			defaultNoMatch += generateFrameworkSection(nomatch, new String[]{"COUNT", "count='"+count+"'", "COND", "", "REPROMPT", "false","WAV","","NEXTMENU",hup}, false);
  		}

 		if(!defaultNIAdded) {
  			String count = "3";
			for(int k=1;  k<Util.val(count);k++) {
				defaultNoInput += generateFrameworkSection(noinput, new String[]{"COUNT", "count='"+k+"'", "COND", "", "REPROMPT", "true","WAV","9002.wav","NEXTMENU",""}, false);
			}
  			defaultNoInput += generateFrameworkSection(noinput, new String[]{"COUNT", "count='"+count+"'", "COND", "", "REPROMPT", "false","WAV","","NEXTMENU",hup}, false);
  		}
*/
		return inputerrors + defaultNoMatch + defaultNoInput;
	}

	
	/** Formerly added a TO DO to tell the app developer to translate the voice and status segment databases
	 * using voice_segment_database and status_segment_database vars
	 * 
	 * This function is a placeholder in case an automated method becomes available to process the databases
	 * 
	 * @param appName App name e.g. IBMHELP
	 * @param menuName Menu name e.g. WELCOME_VARS
	 * @param menu Menu object to operate on
	 * @return
	 */
	private String processVoiceSegmentDatabase(String appName, String menuName, Menu menu) {
  		String result = "";
  		String voice_segment_database = menu.get("voice_segment_database") == null ? null : eval(menu.get("voice_segment_database").expr);
  		if(voice_segment_database != null) {
//  			if(!voice_segment_database.equals(appName+".VDB")) 
//  				result += TO DO("Non standard voice database name", voice_segment_database+"' Expected: "+appName+".VDB");
//	 	  	else
  	 	  		result += "\t\t<!-- TO"+"DO: Process voice_segment_database "+voice_segment_database+"-->\r\n";
  		}

  		String status_segment_database = menu.get("status_segment_database") == null ? null : eval(menu.get("status_segment_database").expr);
 	  	if(status_segment_database != null) {
// 	  		if(!status_segment_database.equals(appName+"S.VDB"))
//  				result += TO DO("Non standard voice database name", status_segment_database+"' Expected: "+appName+"S.VDB");
// 	  		else
 	  			result += "\t\t<!-- TO"+"DO: Process status_segment_database "+status_segment_database+"-->\r\n";
 	  	}
  		return result;
  	}

	
	String stripParens(String s) {
		if(!s.startsWith("(") || !s.endsWith(")"))
			return s;
		return s.substring(1,s.length() - 1);
		
	}
	
	/** generateSubmenuSet Generates a <Set> node for each name=expression pair.<br>
	 * @param Menu The menu name
	 * 
	 * <br>
	 * <b>STEPS</b>
	 */
	String generateSubmenuSet(Menu menu) {
		String contents = "", menuDefault = "", menuDefaultDefault = "";
		List<Line> lines = menu.lines;
		
		// If the current menu is menuname_VARS and a corresponding menuname_MENU exists, then add INITOVERRIDES 
		String name = menu.menuName;
		if(name.endsWith("_VARS") && INIFile.currIniText.contains("["+name.replace("_VARS", "_MENU")+"]")) {
			contents = generateSet(menu, "_rc", "(INITOVERRIDES('"+name+"'))", "") + contents; 
		}
		
		/// <ol>
		/// <li> For each variable
 		for(int i=0;i<lines.size();i++) {
 			/// - If it is timeout_max or invalid_select_max - default to timeout_max_default - they are not explicitly set if they are set to 3<br>  
 			//if(keys[i].toString().indexOf("default_timeout_action") >= 0 || keys[i].toString().indexOf("default_invalid_select_action") >= 0) 
 			//	continue;
 			Line line = lines.get(i);
 			
			if(line.var.equalsIgnoreCase("backup_menu_tone"))
 				globalBackupKey = stripParens(line.expr.trim());

 			if(line.var.equalsIgnoreCase("repeat_menu_tone"))
 				globalRepeatKey = stripParens(line.expr.trim());
 			
 			/// - If the var is play_seg, add an < Audio > XML element to the menu 
 			if(line.var.equals("play_seg")) {
 	 			menu.play_seg +=  generateFrameworkAudioSection(line.cond,eval(line.expr)+".wav",null, null, true);
 	 		//} else if(line.var.equals("cur_ini") && (line.cond==null || line.cond.length() == 0) && menu.curIniCount == 1) {

 	 		/// <b> 6. Add a menudefault to transition to the next menu (cur_ini)</b><br>
 			// cur_ini				= 'MENU_CHANGE' - next ini section
 	 		// TO DO add example to doc
	 	 	/*		if(!line.expr.contains("'")) {
	 	 				contents += TO DO("The next menu appears to be a variable - adding in menudefaults which you can customize to go to the possible submenus", cur_ini);
	 					contents += generateFrameworkSection(menuDefaultSubmenu, new String[]{"DEST","MENUDEFAULT_VARS", "HANDLER", "cond=\""+line.expr+"=='MENU_DEFAULT'\""}, false);
	 					contents += generateFrameworkSection(menuDefaultSubmenu, new String[]{"DEST","MENUABC_VARS", "HANDLER", "cond=\""+cur_ini.expr+"=='MENUABC'\""}, false);
	 	 			}
	 	 	*/
 	 		//	String s = generateFrameworkSection(menuDefaultSubmenu, new String[]{"DEST",eval(line.expr), "HANDLER", ((line.cond == null || line.cond.length() == 0) ? "" : "cond=\""+line.cond+"\"")}, false);
 				//if(line.cond == null || line.cond.length() == 0)
 				//	contents += s;
// 	 				menuDefaultDefault = s;
 	 		//	else
 	 		//		menuDefault += s;

 	 		/// - If the variable is cur_function, add a TO DO to make sure the function is implemented	
 	 		} else if(line.var.equals("cur_function")) {
 				String value = line.expr;
 				// String value = menu.get(lines[i]).toString();
 				if(value.indexOf('=') < 0 || value.indexOf(')') < 0 )
 					continue; 
 				value = value.substring(value.indexOf("=") + 1);
 				value = value.substring(0,value.lastIndexOf(")"));
 				value = value.substring(0,value.lastIndexOf(")")+1);
 				
 				if(value.indexOf("play_text") >= 0) {
 					value = value.replaceAll("''", "");
 					contents += generateSet(menu, "rc", "("+value+")", line.cond);
 					contents += generateFrameworkSection(audio, new String[] {"COND", "", "WAV", "DOLLAR_SIGNrc"}, false);
 				} else {
 					contents += TO_DO("Verify function call is implemented", value);
 					contents += generateSet(menu, "rc", value, line.cond);
 				}
 				
 				//MigrationDebug.add(value.split("\\(")[0]);
 			/// - Skip timeout_max
 			} else if(",timeout_max,".indexOf(","+line.var+",") >= 0 && Util.val(eval(menu.get(line.var).expr)) == timeout_max_default) {
 				continue;
 	 		/// - Skip invalid_select_max
 			} else if(",invalid_select_max,".indexOf(","+line.var+",") >= 0 && Util.val(eval(menu.get(line.var).expr)) == invalid_select_max_default) {
 	 			continue;
 			//} else if(",cur_prompt,".indexOf(","+keys[i]+",") >= 0 && eval(vars.get(keys[i])).equals("main")) {
 	 		//	continue;
 			} /*else if(",xfer_file,xfer_type,xfer_connect,xfer_search,".indexOf(","+keys[i]+",") >= 0) {
 				String xfer = eval(vars.get("xfer_file"));
 				if(xfer != null && xfer.indexOf("xfer.ini") < 0)
 					throw new RuntimeException("Unsupported xfer_file:"+xfer);
 				xfer = eval(vars.get("xfer_type"));
 				if(xfer != null && xfer.indexOf("DT") < 0)
 					throw new RuntimeException("Unsupported xfer_type:"+xfer);
 				xfer = eval(vars.get("xfer_connect"));
 				if(xfer != null && xfer.length() > 0)
 					throw new RuntimeException("Unsupported xfer_connect:"+xfer);
 				xfer = eval(vars.get("xfer_search"));
 				if(xfer != null && xfer.length() > 0)
 					throw new RuntimeException("Unsupported xfer_search:"+xfer);
 					
 			}*/ 
 			
			/// The following are considered special variables that the framework generates into structures instead of explictly setting their values<br>
 			/// Processing of these variables is handled in other parts of the translation<br>
 			/// Here are the defaults:<br>
 			/// - ini_file: Set to this file name e.g. ace.xml
 			/// - voice_segment_database=Audio files are now stored in audio/$appName/$language/*.wav
 			/// - status_segment_database=Status audio files are now stored in audio/$appName/$language/status/*.wav
 			/// - cur_appl= e.g. GENME - No longer set unless determined needed for compatability reasons
 			/// - play_seg: becomes an <Audio> tag
 			else if("choices,start_time,ini_file,voice_segment_database,status_segment_database,play_seg,".indexOf(","+lines.get(i).var+",") < 0) {

				if((""+line.var).startsWith("cond:"))
					continue;

//				String unsupportedVars = ","+properties.getProperty("unsupportedVars")+",";
//				if(unsupportedVars.contains(","+line.var+","))
//					continue;

	 				if(line.var.equalsIgnoreCase("call_status")) {
		 				//contents += generateSet(menu, "cur_ini", line.expr, line.cond);
		 				HUP_MENU_CHECK = generateFrameworkSection(menuDefaultSubmenu, new String[]{"DEST","HUP_MENU", "HANDLER", "cond=\"DOLLAR_SIGNcall_status EQ HUP\""}, false) + menuDefault;
 					}
	 				
 					if(line.var.equals("xfer_file")) {
 						if(line.expr.indexOf("/") >= 0)
							line.expr = line.expr.substring(line.expr.lastIndexOf('/') + 1); 
 					}
 					if(line.var.equals("cur_appl")) {
 						if(line.cond.length() == 0) {
		 					log(DEBUG, "Line ignored - cur_appl:" + line.toString());
	 						continue;
 						} else {
							curApplList.add(line.expr);
 						}
 					}
	 				if((""+line.var).equals("cur_ini") && menu.curIniCount == 1) {
	 					log(DEBUG, "Line ignored - curIniCount == 1:" + line.toString());
	 					continue;
	 				}
	 				
 					if(line.var.equalsIgnoreCase("play_status_repeat")) {
 						contents += TO_DO("play_status_repeat functionality must be implemented by hand", line.toString());
 					}

 					if(line.var.equalsIgnoreCase("call_flow_name")) {
 						contents += generateSet(menu, "applicationName", line.expr, line.cond);
 					}

	 				contents += generateSet(menu, line.var, line.expr, line.cond);
 			}
 			
 			String expr = (""+line.expr).toUpperCase();
 	 		if(expr.contains("SET_TIMEOUT")) {
				contents += TO_DO("SET_TIMEOUT() encountered. Add vxml='timeout:Ns' to "+menu.menuName.replace("_VARS", "_MENU"), line.toString());
 	 		}
 	 		if(!line.var.startsWith("default_") && (expr.contains("LINK_") || (""+line.expr).contains("GENME_") || (""+line.expr).contains("XFER_"))) {
				contents += TO_DO("LINK encountered in runtime expression. Write code by hand to handle link", line.toString());
 	 		}

 		}

 		if(menu.curIniCount > 1)
 			contents += "\t\t<Set var=\"cur_ini\" expr=\"(MENUNAME(cur_ini))\"/>\n";
 		/// Other special variables:
 		/// status_entered, status_avoided: If the application turns off status messages, gate the play status with a cond and add the variable<br>
 		/// set start_time inside WELCOME<br>
 		/// Default call_status to OK and language_country to language from global.properties<br>
 		
		return contents + menuDefault + menuDefaultDefault;
	}

	private String generateSet(Menu menu, String key, String value, String cond) {
		if(key.equals("choices"))
			return "";
		
		//String cond = null;
		
		/*if(value == null) {
			Line line = menu.get(key);
			value = handleLink(line.expr);
			cond = line.cond;
		}*/
			

		if(cond != null && cond.length() > 0) {
			return generateFrameworkSection(set, new String[]{"COND",cond , "NAME",""+key,"EXPR",value}, true);
		}
		else
			return generateFrameworkSection(set, new String[]{"NAME",""+key,"EXPR",value}, true);
	}
	
	/** Parses the contents of a link e.g. 	main_1_1;XFER_918004267378
	 * 
	 * @param varValue The link
	 * @return The link normalized 
	 */
	private static String getLink(String varValue) {
		log(DEBUG, "getLink("+varValue+")");
		
		//XFER_1030103;language_country='CF';rc=play_segment("2101")
		//main_1;LINK_GENME;cur_ini='ACE'
		
		if(varValue.indexOf("LINK_GENME") == 0 || varValue.indexOf("LINK_GENME") == 1) {
			String[] items = varValue.split(";");
			
			for(int i=0;i<items.length;i++) {
				try {
					if(items[i].indexOf("cur_ini") >= 0 && items[i].indexOf("=") >= 0) {
						log(DEBUG, ">"+items[i]+"<");
						String[] subitems = items[i].split("=");
						return(subitems.length > 1 ? subitems[1].replace('\'', ' ').trim() : ""); 
					}
				} catch(Exception e) {
					log(DEBUG, "getLink - error, skipping:"+items[i]);
					e.printStackTrace();
					
				}
			}
			varValue = varValue.contains("=") ? varValue.split("=")[1].replace('\'', ' ').trim() : varValue;
		}
		return varValue.indexOf("XFER") == 0 ? "XFER_VARS" : varValue;
		
	}
	
	/** Parses the contents of a link e.g. 	main_1_1;XFER_918004267378
	 * 
	 * @param varValue The link
	 * @return The link normalized 
	 */
	private String getLinkVars(String varValue) {
		log(DEBUG, "getLinkVars("+varValue+")");
		String result = "";
		if(varValue.startsWith("XFER_")) {
			result = "xfer_var="+varValue.substring(5);
		} else if(varValue.indexOf("LINK_GENME") == 0 || varValue.indexOf("LINK_GENME") == 1) {
			String[] items = varValue.split(";");
			for(int i=1;i<items.length;i++) {
				try {
					if(items[i].indexOf("cur_ini") >= 0)
						continue;
					result += (result.length() > 0 ? ";" : "") + items[i];
					log(DEBUG, "getLinkVars >"+items[i]+"<");
				} catch(Exception e) {
					log(DEBUG, "getLinkVars - error, skipping:"+items[i]);
					e.printStackTrace();
					
				}
			}
			//varValue = varValue.contains("=") ? varValue.split("=")[1].replace('\'', ' ').trim() : varValue;
		}
		
		result = result.replace("=" ,":");
		if(result.toLowerCase().indexOf("cur_prompt:") >= 0 && result.indexOf("cur_prompt_override") < 0)
			result=result.replace("cur_prompt:", "cur_prompt_override:true;cur_prompt:");
		return result;
		
	}

	
	/** Generates a <TO DO> element for unsupported elements
	 *  
	 * @param desc Description of the unsupported statement
	 * @param info The text of the line that could not be translated
	 * @return <TO DO> element
	 * 
	 * <h2>TO DO</h2>
	 * 
	 *  Generates a <TO DO> element for any ini file statement that we do not recognize<br>
	 *  For example: 
	 *  <pre>
	 *  <TO DO description="Unsupported processor" info="COMMON_FUNCS"/>
	 *  </pre>
	 *
	 * Uses the ignore_these_todos property to ignore extraneous TODOs for ALPHAENT,WEBSV,esmrt_logger,voice database name,COMMON_FUNCS,voice_trust for now since we will be supporting these functions<br>
	 * - ALPHAENT - Get alphanumeric serial number. See com.ibm.ivr.framework.sca.handlers.ALPHAENT handler class
	 * - WEBSV - Web services
	 * - esmrt_logger Defer for now until logging is solidified
	 */
	String TO_DO(String desc, String info) {
		String todo = "\t\t<!-- TO"+"DO  "+desc+" info=\""+info.trim()+"-->\r\n"; //.replace('"', '\'')
		

		String[] ignore = properties.getProperty("ignore_these_todos").split(",");//"ALPHAENT|WEBSV|esmrt_logger|voice database name|COMMON_FUNCS|voice_trust|unable to parse".toLowerCase().split("\\|"); 		
		String todo2 = todo.toLowerCase();

		if(debug) {
			if(uniqueTodo.contains(todo2)) {
				uniqueTodo = uniqueTodo.replace("]"+todo2, ","+currentIniName+"]"+todo2);
			} else {
				uniqueTodo += "["+currentIniName+"]"+todo2;
			}
			Util.putFile("unique.todo.txt", uniqueTodo, false);
		}
		
		
		boolean bignore = false;
		for(int i=0;i<ignore.length;i++)
			if(todo2.indexOf(ignore[i]) >= 0) {
				log(INFO,"ignoring TODO:" +todo);
				bignore = true;
			}
		if(!bignore) {
			if(debug) Util.putFile(this.currentIniName+".todo.txt", todo, true);
			if(debug) Util.putFile("debug/GLOBAL2.todo.txt", todo, true);
		}
		if(todo2.indexOf("unable to parse") >= 0)
			if(debug) Util.putFile("debug/GLOBAL.todo.txt", todo, true);
		log(INFO,todo.trim());
		return(todo);
	}
	private String uniqueTodo = "";

  	/*String writeFrameworkConfig(String basePath, String name, String sections) {
		String path = basePath+"/JavaSource/ivrmapping.properties";
		String buff = ivrmappingProperties; 			//Util.getFile(path);
		buff = buff.replaceAll("APPSECTIONS",app);
		buff = buff.replaceAll("TESTNUMBERS","");
		Log.log(null,"Writing "+path, false);
		if(debug) Util.putFile(path, buff, false);
  	}*/

	
	/** Holds information about menu choices
	 * 
	 */
	class Choice {
		// List of choices in this menu
		Map<String, Choice> choices = null;
		
		// Menu level for this choice e.g. M or 1_2
		String menuLevel = "";
		
		// Choice name
		String name = "";
		
		// Choice dtmf
		String dtmf = "";
		
		// Handler to call
		String handler = "";
		
		// Parameters and variables to set
		String parameters = "";
		String parameters2 = "";
		
		// Menu to go to
		String menuName = "";
		
		// Raw text of the line
		String line = "";
		
		/** Adds a choice to the list of choices for this menu
		 * 
		 * @param mName Name of the menu
		 * @param name_dtmf e.g. main_1
		 * @param handler_parameters handler and variables
		 * @param parameters Variables to set
		 * @param menuLevel Menu level to check
		 * @param line Raw text of the choice
		 */
		void addChoice(String mName, String name_dtmf, String handler_parameters, String parameters, String menuLevel, String line){
			if(choices == null)
				choices = new LinkedHashMap<String, Choice>();
			String tempDtmf = name_dtmf.indexOf('_') < 0 ? " " : name_dtmf.substring(name_dtmf.indexOf('_')+1);
			Choice c = choices.get(""+tempDtmf.charAt(0));
			if(c == null) {
				c = new Choice();
				c.menuName = mName;
				this.menuName = mName;
				c.menuLevel = menuLevel;
				c.name = name_dtmf.indexOf('_') < 0 ? name_dtmf : name_dtmf.substring(0, name_dtmf.indexOf('_'));
				this.name = c.name;
				c.dtmf = ""+tempDtmf.charAt(0); 
				c.handler = handler_parameters.substring(0, handler_parameters.indexOf('_'));
				c.parameters = handler_parameters.substring(handler_parameters.indexOf('_')+1).trim();
				c.parameters2 = parameters;
				c.line = line;
				choices.put(""+tempDtmf.charAt(0), c);

			}

			if(tempDtmf.contains("_")) {
				String newDtmf = tempDtmf.substring(2); 
				c.addChoice(mName, c.name+ "_" + newDtmf, handler_parameters, parameters, c.menuLevel + (c.menuLevel.length() > 0 ? "_" : "") + c.dtmf, line);
			}

		}
		
		public String toString() {
			return toString("");
		}
		
		/** Choice format:
		 * main_2_3_*;LINK_XXXX;cur_ini=...;item=value;...
		 * or
		 * main_2_4_2;XXXX_VMADMIN;item=value;...
		 *	main_2_3_*;LINK_GENME;cur_prompt='main_2_3';invalid_select_max=0;timeout_max=0;max_attempts=max_attempts + 1
		 * @return
		 */
		public String parseChoice() {
			String[] fields = this.line.split(";");
			String result = Migration.parseChoice(fields, menuName, line);
			return result;
		}


		/** Convert a choice to XML
		 * 
		 * @param previousmenuLevel This function is recursive and 
		 * @return A list of choices in XML form
		 */
		public String toString(String previousmenuLevel) {
			String result1 = "", result3 = "";
			if(choices!= null) {
				if(previousmenuLevel.length() == 0 && menuLevel.length() == 0 && dtmf.length() > 0) {
					 String s = "\t\t\t<!-- The following are sub selections of the "+dtmf+" dtmf press -->\r\n";
					 result1 += s;
				}
				Object[] keys = choices.keySet().toArray();
				Arrays.sort(keys);
				for(int i=0;i < keys.length;i++) {
					Choice c = choices.get(keys[i]);
					result1 += ""+(dtmf.length() > 0 ? "\t" : "")+c.toString((previousmenuLevel.length() > 0 ? previousmenuLevel+ "_" : "") + menuLevel);
				}
			} 
			
			//else {
			if(dtmf.length() > 0) {
				if(choices == null)
					result3 += ""+ parseChoice(); 

				String cond = menuLevel.length() > 0 ? cond("menuLevel","==","'"+menuLevel+"'") : cond("menuLevel", "==", "'M'");
				String temp = previousmenuLevel.length() > 0 ? previousmenuLevel + "_" : "";
				temp = (temp.length() > 0 || menuLevel.length() > 0) ? temp + menuLevel + "_" : ""; 
				//String expr = choices != null ? ("menuLevel='"+temp+dtmf+"'") : "";
				
				if(choices != null) {
					result3 += ""+generateFrameworkSection(choice, new String[] {"DTMF", dtmf, "COND", cond, "DEST", "selection:"+dtmf, "TARGETTYPE", "submenu", "TARGETNAME", menuName}, true);
				} 			
			}
			
			return result3 + result1;
		}


		/** Generates the < Audio > prompts that come before the choices 
		 * 
		 * @param previousmenuLevel The menu level to check before executing this choice
		 * @param genStatus 
		 * @return
		 */
		public String toPrompt(String previousmenuLevel, boolean genStatus) {
			String result1 = "", result2 = "";
			// If this menu has sub menus
			if(choices != null) {
				Object[] keys = choices.keySet().toArray();
				Arrays.sort(keys);

				// For each sub-menu, call toPrompt()
				for(int i=0;i < keys.length;i++) {
					Choice c = choices.get(keys[i]);
					result1 += c.toPrompt(menuLevel, false);
				}
				
				// Generate audio for this parent menu
				log(DEBUG,"menulevel: "+menuLevel);
//					//String cond = (menuLevel.length() > 0 ? "menuLevel=='"+menuLevel+"'" : "");
//					String temp = previousmenuLevel.length() > 0 ? previousmenuLevel + "_" : "";
//					temp = (temp.length() > 0 || menuLevel.length() > 0) ? temp + menuLevel + "_" : "";
//					temp = temp+dtmf;
					String temp = menuLevel.length() == 0 ? dtmf : menuLevel + "_" + dtmf;
					if(temp.length() == 0)
						temp = "M";
					String cond = cond("menuLevel","==","'"+temp+"'");
	//				result2 = generateFrameworkSection(audio, new String[] {"COND", cond, "WAV", "wav('"+name+(temp.length() > 0 ? "_" : "")+temp+"')", "TTS", "eval(tts('"+name+(temp.length() > 0 ? " " : "")+temp+"'))"});
					//String menu = this.menuName + "_" +
					String menu = temp.replaceAll("_", "");
					result2 = generateFrameworkAudioSection(cond,menu, temp, menuName, genStatus);
					return(result2 + result1);
			}

			
			return("");

		}
		
		
		
		public String toPromptJunk(String previousmenuLevel, boolean genStatus) {
			String result1 = "", result3 = "";
			if(choices!= null) {
				if(previousmenuLevel.length() == 0 && menuLevel.length() == 0 && dtmf.length() > 0) {
					 String s = "\t\t\t<!-- The following are sub selections of the "+dtmf+" dtmf press -->\r\n";
					 result1 += s;
				}
				Object[] keys = choices.keySet().toArray();
				Arrays.sort(keys);
				for(int i=0;i < keys.length;i++) {
					Choice c = choices.get(keys[i]);
					result1 += "AA"+(dtmf.length() > 0 ? "\t" : "")+c.toPrompt((previousmenuLevel.length() > 0 ? previousmenuLevel+ "_" : "") + menuLevel, false)+"CC";
				}
			} 
			
			//else {
			if(dtmf.length() > 0) {
				if(choices == null)
					result3 += "JJ"+ parseChoice()+"KK"; 

				String cond = menuLevel.length() > 0 ? cond("menuLevel","==","'"+menuLevel+"'") : cond("menuLevel", "==", "'M'");
				String temp = previousmenuLevel.length() > 0 ? previousmenuLevel + "_" : "";
				temp = (temp.length() > 0 || menuLevel.length() > 0) ? temp + menuLevel + "_" : ""; 
				//String expr = choices != null ? ("menuLevel='"+temp+dtmf+"'") : "";
				
				if(choices != null) {
					temp = temp+dtmf;
					temp = temp.length() == 0 ? "M" : temp;
					cond = choices != null ? cond("menuLevel","==","'"+temp+"'") : "";
					String menu = (temp.length() == 0 ? "M" : temp.replaceAll("_", ""));
					
					result3 += "XX"+generateFrameworkAudioSection(cond,menuLevel+":"+menu, temp, menuName, genStatus)+"YY";

					
					
					//result3 += ""+generateFrameworkSection(choice, new String[] {"DTMF", dtmf, "COND", cond, "DEST", "selection:"+dtmf, "TARGETTYPE", "submenu", "TARGETNAME", menuName}, true);
				} 			
			}
			
			return result3 + result1;
		}


		
	}

	/** Parses the ini file choice
	 * 
	 * @param fields The values in between ';'
	 * @param menuName Name of the menu that owns this choice
	 * @param line The raw text of the line
	 * @return 
	 */
	public static String parseChoice(String[] fields, String menuName, String line) {
		//Map fieldMap = new LinkedHashMap<String, String>();
		if(fields.length <= 0 || fields[0].lastIndexOf("_") < 0) {
			log(DEBUG, "Empty choice:" + line);
			return "";
		}
			
		log(DEBUG, "line:" + line);
		fields[0] = fields[0].replaceAll("main_", "");
//		fields[0] = fields[0].replaceAll("main", "M");
		String menuLevel = fields[0].length() > 1 ? fields[0].substring(0, fields[0].lastIndexOf("_")) : "M";
		String dtmf = ""+fields[0].charAt(fields[0].length() - 1);
		String link = "GENME";
		String ini = menuName;
		String dest = "selection:"+dtmf;
		String todo = "";
		for(int i=1;i<fields.length;i++) {
			if(fields[i].trim().length() == 0)
				continue;
			if(fields[i].indexOf("=") < 0) {
				if(fields[i].indexOf("LINK_") >= 0) {
					link =  fields[i].substring(5); // leverage getLink()
				} else if(fields[i] .indexOf('_') > 0){
					link = fields[i].split("_")[0]; // leverage getLink()
					ini =  fields[i].split("_")[1].trim();
				} else {
					throw new RuntimeException(menuName + ": invalid link. line="+line);
				}
				if(link.equals("XFER") && !menuName.equalsIgnoreCase("XFER_VARS"))
					link = "XFER_VARS";
					
				//link = getLink(line.substring(line.indexOf(";")+1));
			} else {
				String name = fields[i].split("=")[0];
				String value = fields[i].split("=")[1].replaceAll("'","").trim();
				
				if(name.indexOf("invalid_select_max") >= 0)
					todo += "<!-- TODO This link probably links back to the same menu - if so, remove these counters"+ line+"-->";
				
				if(name.equals("cur_prompt"))
					dest += ";cur_prompt:"+value; //.replace("main_","").replace("main","M");
				else if(name.equals("cur_ini"))
					ini = value; 
				else
					dest+=";"+name+":"+value;//fields[i].replace('=', ':').trim();
				// "selection:"+dtmf : "target"+targetName
			}
			
		}
		
		

		String targetname = normalizeMenuName(link, "MENU");
		if(!link.equals("GENME")) {
			if(link.startsWith("GVI")) {
				targetname = ini+"_MENU";
				dest += ";returnMenu:XFER_VARS";
			} else {
				dest += ";xfer_var:"+ini + (link.startsWith("XFER") ? "" : ";returnMenu:"+menuName);
			}
		} else {
			targetname = menuName.replace("_MENU", "").equals(ini) ? normalizeMenuName(ini, "MENU") : normalizeMenuName(ini, "VARS");
		}
		
		if(dest.toLowerCase().indexOf("cur_prompt:") >= 0 && dest.indexOf("cur_prompt_override") < 0)
			dest=dest.replace("cur_prompt:", "cur_prompt_override:true;cur_prompt:");

		String s = "";
//		if(fields[0].equals("main_NoMatch")) {
//			link = replaceStuff(nextMenuFragment, new String[]{"NEXTMENU", targetname});
//			s = replaceStuff(nomatch, new String[]{"COUNT", "count='"+"2"+"'" + dest, "COND", cond("menuLevel","==",menuLevel), "REPROMPT", "false","WAV","","NEXTMENU",link}	);
//		} else
			s = replaceStuff(choice, new String[] {"DTMF", dtmf, "COND", cond("menuLevel","==",menuLevel), "DEST", dest , "TARGETTYPE", "submenu", "TARGETNAME", targetname});
		log(DEBUG, "menuLevel:" + menuLevel+" dtmf:"+dtmf);
		log(DEBUG, "choice:" + s);
		String result = todo+"\n\t<!-- "+line.trim()+"-->\n"+s;
		return result;
	}

	
	/**
	 * <h2>translateStatement</h2>
	 * Translates ASSIGN, LINEOUT, CHOICE, IF, and SAY statements into framework XML
	 * See the grammar described in translateSection()
	 * 
	 * @param menuName Name of menu that owns this line
	 * @param menu Menu object to store result
	 * @param root Root of parse tree 
	 * @param line Raw text of line to process
	 * @param cond Condition
	 * @param subline Subsequence of characters from the line being worked on
	 * @return XML
	 * <b>STEPS</b>
	 */
	String translateStatement(String menuName, Menu menu, Object root, String line, String cond, String subline) {
		Object node = getType(root) == IniFileParser.ASSIGN ? root : getChild(root, 0);
		/// - If the statement is ASSIGN e.g. a=b, add it to the variables list to be <Set>  
		if(getType(node) ==  IniFileParser.ASSIGN) {
			String expr1 = subline;
			String var1 = "rc";
			if(expr1.toUpperCase().contains("rexx") && !expr1.toUpperCase().contains("SET_TIMEOUT")) {
				throw new RuntimeException("rexx line encountered"+subline);
			
			} 
		
			if(expr1.indexOf('=') > 0 && isIdentifier(expr1.split("=")[0])) {
				var1 = expr1.substring(0,expr1.indexOf("=") - 1).trim();
				expr1 = expr1.substring(expr1.indexOf("=")+1).trim();
				if(var1.startsWith("default_invalid_select") || var1.startsWith("default_timeout")) {
					log(DEBUG, "translateStatement():"+var1+"="+expr1);
					// LINK_GENME;cur_ini = RSAPW_START
					if(expr1.startsWith("'LINK_") && expr1.indexOf("cur_ini") > 0) {
						expr1 = eval(expr1);
						expr1 = expr1.substring(expr1.indexOf("=") + 1).trim();
						if(!expr1.contains("'"))
							expr1 = "'"+expr1+"'";
					}
						
				} else {
					expr1 = convertExpression(expr1);
				}
			} else {
				expr1 = convertExpression(expr1);
			}


			//cond1 = convertExpression(cond1);
			menu.put(var1, expr1, null);
			
			log(DEBUG, var1+":"+expr1);
			
			/*String name = node.getChild(0).toString();
			String value = node.getChild(2).toString();
			
			if(value.toLowerCase().contains("rexx"))
				value = line; 
			menu.put(name, value, cond);
			
			log(DEBUG, name+":"+value);
			if(debug) Util.putFile("expression.bad.txt", name+":"+value+"\r\n",true);*/
		/// - If the node is LINEOUT, set lineout and fileout variables which will be used to set up a WEBSV handler call
		} else if(getType(node) ==  IniFileParser.LINEOUT) {
			String name = getChild(node,2).toString();
			String expression = "";//node.getChild(4).toString();
			// If the value is complex, flag it
			for(int i=5;i<getChildCount(node) && getType(getChild(node,i)) != IniFileParser.THEN;i++) {
				expression += getChild(node, i).toString();
			}
			String fileOut = globals.get("fileout").expr;
			if(fileOut == null)
				globals.put("fileout", name, null);
			
			String lineout = globals.get("lineout").expr;
			if(lineout == null)
				lineout = "";
			globals.put("lineout", lineout + expression+"\r\n", null);
			log(DEBUG, name+":"+expression);
		/// - If the node is Choice, set up a Choice object to hold the details
		} else if(getType(node) ==  IniFileParser.CHOICE) {
			String[] segs = line.split(";");
			String name_dtmf = segs[0];//node.getChild(0).toString();
			String handler_parameters = segs[1];//node.getChild(2).toString();
			String parameters = segs.length > 2 ? segs[2] : "";//node.getChildCount() >= 5 ? node.getChild(4).toString() : "";
			Choice c = menu.choices;
			if(c == null) {
				c = new Choice();
				menu.choices = c;
			}
			// If the value is complex, flag it
			try { 
				c.addChoice(menuName, name_dtmf, handler_parameters, parameters, "", line);
			} catch(RuntimeException e) {
				throw new RuntimeException(e.getMessage()+"Menu Name="+menuName+" line="+line);
			}
			
			if(cond.length() > 0)
				throw new RuntimeException("CondUnsupported:Cond not supported for choice:\n "+line+ "\nchoice:\n"+c.toString());
			//log(DEBUG, c.toString());
			
		/// - If the node is IF, then add a varname:cond cariable, which will be used to put a "cond" attribute into the <Set>
		} else if(getType(node) ==  IniFileParser.IF) {
			String[] parts = subline.split("(T|t)(H|h)(E|e)(N|n)");
			String cond1 = convertExpression(parts[0].substring(parts[0].toUpperCase().indexOf("IF") + 2) );
			String expr1 = parts[1];
			String var1 = "rc";

			if((expr1.indexOf('=') > 0 && isIdentifier(expr1.split("=")[0]))) {
				var1 = expr1.substring(0,expr1.indexOf("=")).trim();
				expr1 = expr1.substring(expr1.indexOf("=")+1).trim();
				expr1 = convertExpression(expr1);
			} else {
				expr1 = convertExpression(expr1);
			}
			
			if(var1.equals("log_data")) {
				
  				log_data += convertExpression(expr1);
			/// - If the node is esmrt_logger, add settings at the beginning of GLOBAL_VARS to trigger end of call logging
			} else 
			
			//cond1 = convertExpression(cond1);
			menu.put(var1, expr1, cond1);
			
			log(DEBUG, var1+":"+expr1+":"+cond1);
		/* String cond1 = "";
			int i=1;
			try {
				for(;i<node.getChildCount() && node.getChild(i).getType() != IniFileParser.THEN;i++) {
					cond1 += node.getChild(i).toString();
				}
				return translateStatement(menuName, vars,(ParseTree) node.getChild(i+1), line, cond1);
			} catch(Exception e) {
				throw new RuntimeException(e.getMessage()+ ": Failed to handle line with cond="+cond+" line="+line);
			}
			*/
			//log(DEBUG, c.toString());
		/// - If the node is SAY, generate <Log>
		} else if(getType(node) ==  IniFileParser.SAY) {
			if(cond.length() > 0)
				throw new RuntimeException("CondUnsupported:Cond not supported for say:\n "+line);

			//int i=1;
			//String value = "";
			//for(;i<node.getChildCount() && node.getChild(i).getType() != IniFileParser.THEN;i++) {
			//	value += node.getChild(i).toString();
			//}
			
			String var = line.substring(4).trim();
			return(generateFrameworkSection(log, new String[]{"EXPR", isIdentifier(var) ? "DOLLAR_SIGN"+var : var}, true));
		
		} else {
			if(line.indexOf("esmrt_logger") >= 0 && LOGGER_PLUGIN_VARS.indexOf("esmart") < 0) {
	  			String esmart = properties.getProperty("esmartLogData");
	  			if(esmart !=null) {
	  				LOGGER_PLUGIN_VARS += generateSet(null, "esmartLogData", esmart, null);
	  				LOGGER_PLUGIN_VARS += generateSet(null, "gsmartLogging", "true", null);
	  			}

				//return(generateFrameworkSection(log, new String[]{"EXPR", line.substring(12).trim()}, true));
			/// - Otherwise, we do not support this line type generate a <TO DO> containing the line information
			} else
				throw new RuntimeException("Unrecognized node type:"+getType(node)+" line: "+line);
		}
		return "";
	}
	
	
	/** These methods provide a way to navigate a tree stricture whose type cannot be determined until runtime *
	 * 
	 * @param node current node
	 * @return integer representing type
	 */
 	private int getType(Object node) {
 		if(node == null)
 			log(0,"");
 		return ((Integer)runMethod(node, "getType", null)).intValue();
 	}

	/** These methods provide a way to navigate a tree stricture whose type cannot be determined until runtime *
	 * 
	 * @param node current tree node
	 * @return number of children
	 */
 	private int getChildCount(Object node) {
 		return ((Integer)runMethod(node, "getChildCount", null)).intValue();
	}

	/** These methods provide a way to navigate a tree stricture whose type cannot be determined until runtime *
	 * @param node current tree node
	 * @return The child indicated by index i
	 */
	private Object getChild(Object node, int i) {
 		return runMethod(node, "getChild", new Object[]{new Integer(i)});
	}

	/** Returns true if the string is an identifier e.g. VARNAME
	 * 
	 * @param string The identifier
	 */
	private boolean isIdentifier(String string) {
		if(string == null)
			return false;
		string = string.trim();
		boolean result = true;
		for(int i=0; i<string.length() ;i++ ) {
			char ch = string.charAt(i);
			if(i==0 && !Character.isJavaIdentifierStart(ch) || i > 0 && !Character.isJavaIdentifierPart(ch))
				result = false;
		}
		return result;
	}


	/** Generate < Audio >
	 * 
	 * @param cond Guard condition for the XML
	 * @param wav Name of the wav file
	 * @param menuLevel Menu level to check first
	 * @param menuName Name of the menu that owns this < Audio >
	 * @param genStatus True if it is a status message
	 * @return < Audio > XML
	 */
	String generateFrameworkAudioSection(String cond, String wav,String menuLevel, String menuName, boolean genStatus) {
		String result = "";
		if(menuName != null && genStatus)
			result += generateSet(null, "menuLevel", "(initMenu('"+menuName+"'))", null);
		if(false && genStatus) {
			result += generateFrameworkSection(property, new String[] {"NAME","bargein", "COND", "(isBargeInEnabled())"}, false);
			result += generateFrameworkSection(audio, new String[] {"COND", "(isStatusToBePlayed())", "WAV", wav+"_S.wav"}, false);
			result += generateFrameworkSection(property, new String[] {"NAME","bargein", "COND", "true"}, false);
		}
		wav = lookupPromptOverride(menuName, wav, menuLevel);
		result += generateFrameworkSection(audio, new String[] {"COND", cond, "WAV", wav}, false);
		return result;
	}

	/** Returns the prompt override wav file 
	 * 
	 * @param menuName Name of the menu
	 * @param wav Name of the wav file
	 * @param menuLevel Current menu level - if all above match prompt_override_main_... then return the specified audio file name 
	 */
	private String lookupPromptOverride(String menuName,String wav, String menuLevel) {
		if(menuName != null && menuLevel != null) {
			Menu menu = Menu.menus.get((""+menuName).replace("_MENU", "_VARS"));
			if(menu == null)
				menu = Menu.menus.get(""+menuName);
			if(menu == null)
				throw new RuntimeException("lookupPromptOverride(): Failed to get menu named: "+menuName);
			Line override = menu.get("prompt_override_main"+(menuLevel.equalsIgnoreCase("M") ? "" : "_"+menuLevel));
			
			wav = override == null 
			? menuLevel.replaceAll("_", "") 
			: override.expr;
		}
		wav = wav.endsWith("wav") ? wav : wav+".wav";

		log(DEBUG,"lookupPromptOverride(): menuName="+menuName+" menu="+menuLevel + " wav="+wav);
		return wav;
	}

	/** Replaces quotes in string to be evaluated 
	 * 
	 * @param expr Expression to be 'eval'uated
	 * @return Expression without quotes
	 */
	private static String eval(String expr) {
		expr = (expr == null ? null : (""+expr).replaceAll("'", "").replaceAll("\"", ""));
		return expr;
		
	}
	
	/** Returns an instance to the requested class. Used to be able to call methods on objects that are not available 
	 * at compile time. This was done to be able to hook in any compiler generator
	 * 
	 * @param className Name of the class 
	 * @return An object of the specified class
	 */
	private Object getInstance(String className) {
		try {
			Class clazz = Thread.currentThread().getContextClassLoader().loadClass(className);
			return clazz.newInstance();
		} catch(Exception e) {
			throw new RuntimeException("Unable to load class: "+className+":"+e.getMessage()+" See README for instructions on generating the lexer and parser needed to parse the ini file");
		}
	}
	
	/** parses the expression and converts it into something we can more easily store into the framework XML
	 * 
	 * @param expr Expression to translate - replaces XML unfriendly characters like '&&' with 'AND'
	 */
	private String convertExpression(String expr) {
		if(expr.indexOf("menuLevel")>=0 || expr.indexOf("initMenu")>=0)
			return expr; 
		 try {
			 String result = expr;
				if(!(expr.trim().length() == 0 || expr.trim().startsWith("/*") || expr.trim().startsWith("//"))) 
  					result = ""+ExpressionXlateParser.parse(expr);
				if(result.startsWith("\"") && result.endsWith("\""))
					result = "'" + result.substring(1, result.length() -1) + "'";

				if(result.startsWith("'") && result.endsWith("'") && result.contains("\"")) {
					result = result.replace('"', '`');
				} else if(result.contains("\"")) {
					result = result.replace('"', '\'');
				}
					
				return(result);
				// log(INFO,t.toStringTree());
				//printTree(tree,0); 
			} catch(Exception e){
				if(debug) Util.putFile("debug/expression.bad.txt", "Exception "+e.getMessage()+":"+expr+"\n",true);
				e.printStackTrace();
			}
		return("TODO: expression needs re-write:"+expr);
	}

	/** 
	 * @param section The variable containing the section template XML
	 * @param replacements The name value pairs that are replaced in the template
	 * @return The framework XML
	 * 
	 Framework sections are generated using templates. For example:<br> 
	<pre> 
	String choice = "		<Choice dtmf='DTMF' targetType='TARGETTYPE' targetName='TARGETNAME' dest='DEST'/>\r\n";
	</pre>
	Generates:<br>
	<pre> 
			<Choice cond="menuLevel=='1'"  dtmf='1' targetType='phone' targetName='main-1' dest='1062531'/>
	</pre> 
	 * The COND and EXPR attributes do not need to be explicitly specified in the template - they are automatically inserted if they are specified<br>
	 * (See log, set, audio,... below)<br>
	 * COND and EXPR are needed for <Choice>, <Audio>, and <Set>
	 */
	String generateFrameworkSection(String section, String[] replacements, boolean parseExpression) {
		log(TRACE, section);
		//String todo = "";
		boolean isMenu = section.equals(subMenu);
		for(int i=0;replacements!= null && i<replacements.length;i+=2) {
			
			// Ignore menus in the ignore menus list
			if(isMenu && replacements[i].equals("MENU_NAME")) {
				String menuName =  "," + replacements[i+1] + ",";
				if(this.ignoreMenus.indexOf(menuName) >= 0)
					return("\t\t<!-- IGNORED MENU:"+menuName+"-->\n");
			}
				
			//String item = replacements[i];
			//String value = replacements[i+1];
			
			//Flag unsupported rexx functions PLAY_SEGMENT, PLAY_TEXT, STREAM, SYSFILEDELETE, SYSSLEEP, and TREXX 
//			String s = value.toUpperCase();
//			if(s.contains("PLAY_SEGMENT") || s.contains("STREAM") ||  s.contains("SYSFILEDELETE") ||  s.contains("SYSSLEEP") || ( s.contains("REXX") && !s.contains("SET_TIMEOUT")))
//				todo = TO DO("Rewrite expression with unsupported function call",s);
		}
		
		
		section = replaceStuff(section, replacements);
		return section;
	}

	public static  String replaceStuff(String section, String[] replacements) {
		for(int i=0;replacements!= null && i<replacements.length;i+=2) {
			log(TRACE, "  "+replacements[i]+"="+replacements[i+1]);
				
			String item = replacements[i];
			String value = replacements[i+1];
			
			if(item.equalsIgnoreCase("DEST"))
			  value = value.replaceAll("\"", "`");
			
			if((item.equals("COND") || item.equals("EXPR"))) {
			// If EXPR or COND is not found in the template, add it
				if(value.length() > 0 && section.indexOf(item) < 0) {
					int pos = item.equals("EXPR") ? section.indexOf("dtmf") : 0;
					pos = section.indexOf(' ', pos > 0 ? pos : section.indexOf('<'));
					if(pos < 0) {
						pos = section.indexOf('>') - 1;
						section = section.substring(0, pos+1)+" " + item.toLowerCase() + "=\"" +value+"\""+ section.substring(pos+1);
					} else {
						section = section.substring(0, pos+1) + item.toLowerCase() + "=\"" +value+"\" "+ section.substring(pos);
					}
				} else {
					section = section.replaceAll(item, value);
				}
			} else {
				section = section.replaceAll(item, value);
			}
		}
		return section;
	}
	
	/** <SubMenu> Element: MENU_CONTENTS is replaced with <Set>, <choice>, etc. mode=DTMF by default */
	String subMenu = "	<SubMenu name=\"MENU_NAME\" HANDLER mode=\"DTMF\" TYPE>\r\nMENU_CONTENTS	</SubMenu>\r\n"; //type="PromptPlay"
		
	/** <Log> Element: EXPR is the text to log */
	String log = "		<Log>EXPR</Log>\r\n";
	
	/** <Set> Element: Sets variable NAME with expression EXPR. */ 
	String set = "		<Set var=\"NAME\" expr=\"EXPR\"/>\r\n";
	
	/** <Property> Element: Turns on/off bargein*/
	String property = "		<property name=\"NAME\"/>\r\n";

	/** <Audio> Element: WAV evaluates to the wav file to play or a (framework expression) */
	String audio = "		<Audio>WAV</Audio>\r\n";
	
	// String menuDefaultHup = "		<MenuDefault cond=\"call_status=='HUP'\" targetType='servlet' targetName='ExitServlet' dest='Default.ServiceMenu'/>\r\n";
	// targetMode='DTMF'
	/** <MenuDefault targetType='submenu'>: DEST is the menu to go to */  
	String menuDefaultSubmenu = "		<MenuDefault targetType=\"submenu\" targetName=\"DEST\" HANDLER/>\r\n";

	// targetMode='DTMF'
	//String menuDefaultApp  ="      <MenuDefault targetType=\"IVRapp\" targetName=\"Thomson_IVR_SvcLocator\" dest=\"locatorUSTV_dtmf\"/>\r\n";
	//String menuDefaultAgent = "		<MenuDefault cond=\"sc-invalid\" targetType=\"submenu\" targetName=\"TryContractNumberAgain\" />\r\n" + 
	//		"		<MenuDefault cond=\"sc-incomplete\" targetType=\"agent\" targetName=\"IncompleteData\" destType=\"RCA-SVC-V-SERVICE_CONTRACTS\" />\r\n" + 
	//		"";
	//String menuDefaultDest = "			targetName=\"USTVMenu\" dest=\"country:US$product:TV$getconnected:false\" />\r\n" + 
	//"";
	//			dest="selfhelpComplete:true$selfhelpStatus:USSelfHelp.MiscellaneousMessage"/>
	//targettype = submenu, targetname=\"VerifyServiceContract\, 
	
	/** <Choice> DTMF is the dtmf key pressed. DEST is the menu or number to go to. TARGETNAME is used for logging and is the name of the menu. */
	static String choice = "		<Choice dtmf=\"DTMF\" targetType=\"TARGETTYPE\" targetName=\"TARGETNAME\" dest=\"DEST\"/>\r\n";
	
	/** <Choice> submenu transfers the user to another menu [SECTION] */
	String choiceSubmenu = "		<Choice dtmf='DTMF' targetType='submenu' targetName='TARGETNAME'/>\r\n";
	// targetMode='DTMF'
/*	String choiceGrammar = "		<grammar>ServiceContract.grxml</grammar> \r\n" + 
			"\r\n" + 
			"		<Choice dtmf=\"@ctrNumber\" targetType=\"submenu\" \r\n" + 
			"		targetName=\"ConfirmContractNumber2\"/>\r\n" + 
			"";
	String choiceServlet = "      <!-- The onemomentplease.wav audio will play while we are looking up the service contract number -->\r\n" + 
			"      <Choice dtmf=\"1\" targetType=\"submenu\"  \r\n" + 
			"        tts=\"One moment, please.\" targetAudio=\"onemomentplease.wav\" handler=\"com.thomson.ivr.controller.servicecontracts.SCHandlerServlet\"\r\n" + 
			"        targetName=\"CheckContractDB\"/>\r\n" + 
			"";
	*/
	static  String nextMenuFragment = "targetType=\"submenu\" targetName=\"NEXTMENU\"";
	/** <InputError> Is used to handle nomatch and noinput */
//	String inputError = "\t\t<InputError COUNT NEXTMENU>\r\nWAV\t\t</InputError>\r\n";

	static String noinput = "		<NoInput COUNT reprompt=\"REPROMPT\" NEXTMENU>WAV</NoInput>\r\n";
	static String nomatch = "		<NoMatch COUNT reprompt=\"REPROMPT\" NEXTMENU>WAV</NoMatch>\r\n";

	//String input Error = "\t\t<InputError COUNT NEXTMENU>\r\nWAV\t\t</InputError>\r\n";

	/** Helper class to hold menu data
	 */
	static class Menu {
		// Choices associated with the menu
		Choice choices = null;
		ArrayList<Line> lines = new ArrayList<Line>();
		static Map<String, Menu> menus = new HashMap<String, Menu>(); 
		public String play_seg = "";
		int curIniCount = 0;
		String menuName = "";
		
		/** Create a new menu holder
		 * 
		 * @param name Name of the menu
		 */
		public Menu(String name) {
			menus.put(name, this);
			this.menuName = name;
		}
		
		/** Gets the line assoiiated with this var name
		 * 
		 * @param var Variable name
		 */
		Line get(String var) {
			for(int i=0;i<lines.size();i++) {
				if(lines.get(i).var.equals(var))
					return lines.get(i);
			}
			return null;
		}

		Line get(String var, String cond) {
			for(int i=0;i<lines.size();i++) {
				if(lines.get(i).var.equals(var) && lines.get(i).cond.equals(cond))
					return lines.get(i);
			}
			return null;
		}

		/** Stores a menu line broken up into condition, variable, and expression
		 * 
		 * @param var Variable name
		 * @param expr Expression
		 * @param cond IF...THEN condition
		 */
		void put(String var, String expr, String cond) {
			if(expr.indexOf("rexxmail") >= 0)
				expr = "EMAIL('"+expr.substring(expr.indexOf("email")+7, expr.lastIndexOf('\'')) + "')"; 

			if(debug && !isSimpleString(cond))
				Util.putFile("debug/expression.good.txt","("+cond+") == true\r\n",true);
			if(debug && !isSimpleString(expr))
				Util.putFile("debug/expression.good.txt",var+"="+ expr+"\r\n",true);

			log(DEBUG, "put("+var+","+expr+","+cond+")");
			
			if(var.equals("cur_ini"))
				curIniCount++;

			Line l = new Line();
			l.var = var;
			if(expr.equals("'0'")) {
				log(INFO,"Quoted zero '0' detected, treating as a number: var="+var);
				expr = "0";
			}
			
			boolean forceAlpha = var.startsWith("prompt_override") || var.startsWith("var_override");
			
			l.expr = (forceAlpha || isSimpleString(expr)) ? eval(expr) : (expr == null || expr.length() == 0 ? "" : "("+expr+")" );
			l.cond = cond == null || cond.length() == 0 ? "" : "("+cond+")";
			
			if(l.expr.indexOf("nil") >= 0)
				log(ERROR,"$$$nil");
			lines.add(l); 
		}
		
		void clear() {
			lines.clear();
		}
	}
	static class Line {
		String var = "";
		String cond = "";
		String expr = "";
		Choice c = null;
		public String toString() {
			return((cond.length() > 0 ? "IF "+cond+" THEN " : "")+var+"="+expr);
			//throw new RuntimeException("toString() unsupported");
			//return expr;
		}
	}
	static int ERROR = 0;
	static int INFO = 1;
	static int DEBUG = 2;
	static int TRACE = 4;
	static int loglevel = INFO;
	String log_data = "";
	
	static void log(int LEVEL, String msg) {
		if(loglevel >= LEVEL || debug) {
			consolelog.append(msg+"\r\n");
			System.out.println(msg);
		} else if(loglevel >= LEVEL) {
			consolelog.append(msg+"\r\n");
			System.out.println(msg);
		}
	}
	
	static boolean isNumeric(String expr) {
		expr = ""+expr.trim();
		if(expr.length() == 0)
			return false;
		for(int i=0;i<expr.length();i++)
		  if(!Character.isDigit(expr.charAt(i)) || expr.charAt(i) == '.')
			return false;
		return true;
	}
	
	static boolean isSimpleString(String expr) {
		//if(expr == null || expr.length() == 0)
		//	return true;
		if(expr == null)
			return true;
		
		//if(isNumeric(expr) || expr.equals("'0'"))
		//	return false;
		if(expr.length() > 0 && expr.startsWith("\"LINK"))
			return true;
		if(!expr.startsWith("'") || !expr.endsWith("'") || expr.contains("("))
			return false;
		return true;
	}
	

	/** Single use function to generate an initial migtration of the recording app properties file
	 */
	private  void generateRecordAppProperties() {
		//		[DIRECTORY_2464]
		//		 access_code                     = '627837'              /* Passcode caller must enter to update status messages         */
		//		 vdb_language_country            = 'US'                  /* Language Identifier that segments are recorded into          */
		//		 log_directory                   = '.\logs\record\'      /* Directory that log files are placed in                       */
		//		 play_type_choice                = 'Y'                   /* Give caller the option to flag recording forced or non-forced*/
		//		 play_type_default               = 'N'
		//		 recording_duration              = '300'                 /* Specifies the max number of seconds a status message can be  */
		//		 recording_database              = 'ATTUNI.VDB'          /* Name of database that status messages are stored in          */
		//		 recording_database_bck          = 'ATTUNI.BCK'          /* Name of database the status message database is backed up to */
		//		 recording_log                   = 'ATTUNI.LOG'          /* Log file that keeps track of active recorded status messages */
		
				
				// no quotes
				// US, UK, Ca_FR
				StringBuffer result = new StringBuffer();
				String buff = Util.getFile("ini/recor.ini");
				if(buff == null || buff.length() == 0)
					return;
				buff = buff.replaceAll("recording_database", "appname");
				buff = buff.replaceAll("access_code", "passcode");
				buff = buff.replaceAll("vdb_language_country", "language");
				buff = buff.replaceAll("language_country", "language");
				String[] lines = buff.split("\n");
				String id = "";
				for(int i=0;i<lines.length;i++) {
					if(lines[i].indexOf("DIRECTORY_") >= 0) {
						id = lines[i].split("DIRECTORY_")[1].split("\\]")[0];
						result.append("\n// DIRECTORY "+id+"\n");
					}
						String[] nameValue = lines[i].split("=");
						if(nameValue == null || nameValue.length < 2)
							continue;
						String name = nameValue[0].trim();
						String value = nameValue[1].trim();
						if(value.indexOf("/*") >= 0)
							value = value.substring(0,value.indexOf("/*")).trim();
						if(name.indexOf("log_") >= 0)
							continue;
						value = value.replaceAll("'", "");
						if("appname,passcode,language,recording_log,appname_bck,recording_duration".contains(name)) {
							if(name.equals("passcode") && !id.equals(value)) {
								result.append(id+"."+name+"="+value+"\n");
							}
							if(name.equals("appname")) {
								result.append(id+".type="+(value.endsWith("S.VDB") ? "S" : "V")+"\n");
								if(value.endsWith("SS.VDB"))
									result.append("// TODO: Previous application was type 'V', not type 'S'"+"\n");
								
								result.append(id+"."+name+"="+value.replace("SS.VDB", "").replaceAll("S.VDB","").replaceAll(".VDB","")+"\n");
									
							}
							if(name.equals("language")) {
								value = value.equals("FR") ? "Ca_"+value : "en_"+value;
								result.append(id+"."+name+"="+value+"\n");
							}
						} else {
							result.append(id+"."+name+"="+value+"\n");
							
						}
				}
				Util.putFile(output+"/RECORD_APP.properties", result.toString(), false);
	}



/** Single use function to generate an initial migtration of the transfer properties file
 *  [BELK]
 *	 DEFAULT;1030209
 *	 BELKPW;1030209
 *
 * Becomes
 * # BELK Application Transfer Targets
 * BELK.DEFAULT=1030209
 * BELK.BELKPW=1030209
*/
	private void generateXferProperties(String fileName) {
				
		StringBuffer result = new StringBuffer();
		String buff = Util.getFile("ini/"+fileName);
		if(buff == null || buff.length() == 0)
			return;
		String[] lines = buff.split("\n");
		String id = "";
		for(int i=0;i<lines.length;i++) {
			if(lines[i].indexOf("[") >= 0) {
				id = lines[i].split("\\[")[1].split("\\]")[0];
				result.append("\n# "+id+" Application Transfer Targets\n");
			}
			String[] nameValue = lines[i].split(";");
			if(nameValue == null || nameValue.length < 2)
				continue;
			String name = nameValue[0].trim();
			String value = nameValue[1].trim();
			if(value.indexOf("/*") >= 0)
				value = value.substring(0,value.indexOf("/*")).trim();
			value = value.replaceAll("'", "");
			
			result.append(id+"."+name+"="+value+"\n");
		}
		
		log(INFO,output+"/xfer/"+fileName);
		Util.putFile(output+"/xfer/"+fileName, result.toString(), false);
	}

}
